/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.9.0 (NJsonSchema v10.6.8.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
// @ts-nocheck

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class BookClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    getById(id: number): Observable<BookViewModel> {
        let url_ = this.baseUrl + "/api/Book/GetById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BookViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BookViewModel>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<BookViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BookViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getList(filterModel: BookGetListFilterViewModel): Observable<PagedResponseOfListOfBookListViewModel> {
        let url_ = this.baseUrl + "/api/Book/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfListOfBookListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfListOfBookListViewModel>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<PagedResponseOfListOfBookListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfListOfBookListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByAuthor(author: string | null | undefined): Observable<Author> {
        let url_ = this.baseUrl + "/api/Book/GetByAuthor?";
        if (author !== undefined && author !== null)
            url_ += "author=" + encodeURIComponent("" + author) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByAuthor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByAuthor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Author>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Author>;
        }));
    }

    protected processGetByAuthor(response: HttpResponseBase): Observable<Author> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Author.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByBookName(bookname: string | null | undefined): Observable<Author> {
        let url_ = this.baseUrl + "/api/Book/GetByBookName?";
        if (bookname !== undefined && bookname !== null)
            url_ += "bookname=" + encodeURIComponent("" + bookname) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByBookName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByBookName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Author>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Author>;
        }));
    }

    protected processGetByBookName(response: HttpResponseBase): Observable<Author> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Author.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByPublisher(publisher: string | null | undefined): Observable<Author> {
        let url_ = this.baseUrl + "/api/Book/GetByPublisher?";
        if (publisher !== undefined && publisher !== null)
            url_ += "publisher=" + encodeURIComponent("" + publisher) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByPublisher(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByPublisher(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Author>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Author>;
        }));
    }

    protected processGetByPublisher(response: HttpResponseBase): Observable<Author> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Author.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByBookSubject(subject: string | null | undefined): Observable<Author> {
        let url_ = this.baseUrl + "/api/Book/GetByBookSubject?";
        if (subject !== undefined && subject !== null)
            url_ += "subject=" + encodeURIComponent("" + subject) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByBookSubject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByBookSubject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Author>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Author>;
        }));
    }

    protected processGetByBookSubject(response: HttpResponseBase): Observable<Author> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Author.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByTranslator(translator: string | null | undefined): Observable<Author> {
        let url_ = this.baseUrl + "/api/Book/GetByTranslator?";
        if (translator !== undefined && translator !== null)
            url_ += "translator=" + encodeURIComponent("" + translator) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByTranslator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByTranslator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Author>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Author>;
        }));
    }

    protected processGetByTranslator(response: HttpResponseBase): Observable<Author> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Author.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addBook(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Book/AddBook";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddBook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddBook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddBook(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProfilePicture(userId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Book/GetProfilePicture/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getThumbnailProfilePicture(bookId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Book/GetThumbnailProfilePicture/{bookId}";
        if (bookId === undefined || bookId === null)
            throw new Error("The parameter 'bookId' must be defined.");
        url_ = url_.replace("{bookId}", encodeURIComponent("" + bookId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThumbnailProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThumbnailProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetThumbnailProfilePicture(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setProfileImage(contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: IHeaderDictionary | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Book/SetProfileImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetProfileImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetProfileImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSetProfileImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadImage(contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: IHeaderDictionary | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Book/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteImage(userId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Book/DeleteImage?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteImage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateBook(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Book/UpdateBook";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateBook(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AuthorClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    getList(filterModel: AuthorGetListFilterViewModel): Observable<PagedResponseOfListOfAuthorViewModel> {
        let url_ = this.baseUrl + "/api/Author/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfListOfAuthorViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfListOfAuthorViewModel>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<PagedResponseOfListOfAuthorViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfListOfAuthorViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllAuthors(): Observable<Author[]> {
        let url_ = this.baseUrl + "/api/Author/GetAllAuthors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAuthors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAuthors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Author[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Author[]>;
        }));
    }

    protected processGetAllAuthors(response: HttpResponseBase): Observable<Author[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Author.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAuthorProfileByAuthorId(id: number): Observable<AuthorProfileViewModel> {
        let url_ = this.baseUrl + "/api/Author/GetAuthorProfileByAuthorId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuthorProfileByAuthorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuthorProfileByAuthorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthorProfileViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthorProfileViewModel>;
        }));
    }

    protected processGetAuthorProfileByAuthorId(response: HttpResponseBase): Observable<AuthorProfileViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthorProfileViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAuthorProfileById(authorid: number): Observable<AuthorProfileViewModel> {
        let url_ = this.baseUrl + "/api/Author/GetAuthorProfileById/{authorid}";
        if (authorid === undefined || authorid === null)
            throw new Error("The parameter 'authorid' must be defined.");
        url_ = url_.replace("{authorid}", encodeURIComponent("" + authorid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuthorProfileById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuthorProfileById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthorProfileViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthorProfileViewModel>;
        }));
    }

    protected processGetAuthorProfileById(response: HttpResponseBase): Observable<AuthorProfileViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthorProfileViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAuthorById(id: number): Observable<AuthorViewModel> {
        let url_ = this.baseUrl + "/api/Author/GetAuthorById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuthorById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuthorById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthorViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthorViewModel>;
        }));
    }

    protected processGetAuthorById(response: HttpResponseBase): Observable<AuthorViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthorViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getlightprofileById(id: number): Observable<AuthorScore> {
        let url_ = this.baseUrl + "/api/Author/GetlightprofileById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlightprofileById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlightprofileById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthorScore>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthorScore>;
        }));
    }

    protected processGetlightprofileById(response: HttpResponseBase): Observable<AuthorScore> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthorScore.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLightprofile(): Observable<AuthorScore[]> {
        let url_ = this.baseUrl + "/api/Author/GetLightprofile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLightprofile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLightprofile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthorScore[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthorScore[]>;
        }));
    }

    protected processGetLightprofile(response: HttpResponseBase): Observable<AuthorScore[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AuthorScore.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    booksByAuthorId(id: number): Observable<Book[]> {
        let url_ = this.baseUrl + "/api/Author/BooksByAuthorId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBooksByAuthorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBooksByAuthorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Book[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Book[]>;
        }));
    }

    protected processBooksByAuthorId(response: HttpResponseBase): Observable<Book[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Book.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addAuthor(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Author/AddAuthor";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAuthor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAuthor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddAuthor(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProfilePicture(userId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Author/GetProfilePicture/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getThumbnailProfilePicture(userId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Author/GetThumbnailProfilePicture/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThumbnailProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThumbnailProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetThumbnailProfilePicture(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getThumbnailProfilePictureByName(fileName: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Author/GetThumbnailProfilePictureByName/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThumbnailProfilePictureByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThumbnailProfilePictureByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetThumbnailProfilePictureByName(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProfilePictureByName(fileName: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Author/GetProfilePictureByName/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProfilePictureByName(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setProfileInfo(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Author/SetProfileInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetProfileInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetProfileInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSetProfileInfo(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userImage User Image
     */
    setProfileImage(userImage: FileParameter): Observable<string> {
        let url_ = this.baseUrl + "/api/Author/SetProfileImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (userImage === null || userImage === undefined)
            throw new Error("The parameter 'userImage' cannot be null.");
        else
            content_.append("userImage", userImage.data, userImage.fileName ? userImage.fileName : "userImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetProfileImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetProfileImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSetProfileImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadImage(contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: IHeaderDictionary | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Author/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteImage(userId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Author/DeleteImage?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteImage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAuthor(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Author/UpdateAuthor";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAuthor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAuthor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateAuthor(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAuthor(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Author/DeleteAuthor/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAuthor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAuthor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteAuthor(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BookSubjectClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    getAllSubjects(): Observable<Subjects[]> {
        let url_ = this.baseUrl + "/api/BookSubject/GetAllSubjects";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Subjects[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Subjects[]>;
        }));
    }

    protected processGetAllSubjects(response: HttpResponseBase): Observable<Subjects[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Subjects.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSubjectById(id: number): Observable<Subjects> {
        let url_ = this.baseUrl + "/api/BookSubject/GetSubjectById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubjectById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubjectById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Subjects>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Subjects>;
        }));
    }

    protected processGetSubjectById(response: HttpResponseBase): Observable<Subjects> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Subjects.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addSubject(category: Subjects): Observable<boolean> {
        let url_ = this.baseUrl + "/api/BookSubject/AddSubject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(category);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSubject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSubject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddSubject(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateSubject(category: Subjects): Observable<boolean> {
        let url_ = this.baseUrl + "/api/BookSubject/UpdateSubject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(category);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateSubject(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSubject(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/BookSubject/DeleteSubject/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSubject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSubject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteSubject(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    getAllCategories(): Observable<Category[]> {
        let url_ = this.baseUrl + "/api/Category/GetAllCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category[]>;
        }));
    }

    protected processGetAllCategories(response: HttpResponseBase): Observable<Category[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCategoryById(id: number): Observable<Category> {
        let url_ = this.baseUrl + "/api/Category/GetCategoryById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category>;
        }));
    }

    protected processGetCategoryById(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getChild(parentid: number): Observable<Category> {
        let url_ = this.baseUrl + "/api/Category/GetChild/{parentid}";
        if (parentid === undefined || parentid === null)
            throw new Error("The parameter 'parentid' must be defined.");
        url_ = url_.replace("{parentid}", encodeURIComponent("" + parentid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChild(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChild(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category>;
        }));
    }

    protected processGetChild(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getParent(): Observable<Category> {
        let url_ = this.baseUrl + "/api/Category/GetParent";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category>;
        }));
    }

    protected processGetParent(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addCategory(category: Category): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Category/AddCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(category);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddCategory(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addChild(category: Category): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Category/AddChild";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(category);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddChild(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddChild(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddChild(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCategory(category: Category): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Category/UpdateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(category);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateCategory(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteCategory(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Category/DeleteCategory/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class LikeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    getLike(likeview: GetLikeSendViewModel): Observable<Like> {
        let url_ = this.baseUrl + "/api/Like/GetLike";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(likeview);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLike(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Like>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Like>;
        }));
    }

    protected processGetLike(response: HttpResponseBase): Observable<Like> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Like.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTotalLikeByEntityIdAndEntityType(entitytype: number, entityid: number): Observable<Like> {
        let url_ = this.baseUrl + "/api/Like/GetTotalLikeByEntityIdAndEntityType/{entitytype}/{entityid}";
        if (entitytype === undefined || entitytype === null)
            throw new Error("The parameter 'entitytype' must be defined.");
        url_ = url_.replace("{entitytype}", encodeURIComponent("" + entitytype));
        if (entityid === undefined || entityid === null)
            throw new Error("The parameter 'entityid' must be defined.");
        url_ = url_.replace("{entityid}", encodeURIComponent("" + entityid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotalLikeByEntityIdAndEntityType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotalLikeByEntityIdAndEntityType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Like>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Like>;
        }));
    }

    protected processGetTotalLikeByEntityIdAndEntityType(response: HttpResponseBase): Observable<Like> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Like.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addLike(dlview: ChangeLikeViewModel): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Like/AddLike";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dlview);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddLike(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddLike(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changeLike(dlview: ChangeLikeViewModel): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Like/ChangeLike";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dlview);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLike(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangeLike(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleterate(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Like/Deleterate/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleterate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleterate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleterate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteBy(likeview: GetLikeSendViewModel): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Like/DeleteBy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(likeview);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteBy(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class RateClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    getAllRates(entitytype: number | undefined): Observable<Rate[]> {
        let url_ = this.baseUrl + "/api/Rate/GetAllRates?";
        if (entitytype === null)
            throw new Error("The parameter 'entitytype' cannot be null.");
        else if (entitytype !== undefined)
            url_ += "entitytype=" + encodeURIComponent("" + entitytype) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Rate[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Rate[]>;
        }));
    }

    protected processGetAllRates(response: HttpResponseBase): Observable<Rate[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Rate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTheAvrRateByEntityIdAndEntityType(entitytype: number, entityid: number): Observable<Rate> {
        let url_ = this.baseUrl + "/api/Rate/GetTheAvrRateByEntityIdAndEntityType/{entitytype}/{entityid}";
        if (entitytype === undefined || entitytype === null)
            throw new Error("The parameter 'entitytype' must be defined.");
        url_ = url_.replace("{entitytype}", encodeURIComponent("" + entitytype));
        if (entityid === undefined || entityid === null)
            throw new Error("The parameter 'entityid' must be defined.");
        url_ = url_.replace("{entityid}", encodeURIComponent("" + entityid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTheAvrRateByEntityIdAndEntityType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTheAvrRateByEntityIdAndEntityType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Rate>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Rate>;
        }));
    }

    protected processGetTheAvrRateByEntityIdAndEntityType(response: HttpResponseBase): Observable<Rate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Rate.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTheAvrRateByEntityIdForAuthors(authorid: number): Observable<Rate> {
        let url_ = this.baseUrl + "/api/Rate/GetTheAvrRateByEntityIdForAuthors/{authorid}";
        if (authorid === undefined || authorid === null)
            throw new Error("The parameter 'authorid' must be defined.");
        url_ = url_.replace("{authorid}", encodeURIComponent("" + authorid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTheAvrRateByEntityIdForAuthors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTheAvrRateByEntityIdForAuthors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Rate>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Rate>;
        }));
    }

    protected processGetTheAvrRateByEntityIdForAuthors(response: HttpResponseBase): Observable<Rate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Rate.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTheAvrRateByEntityIdForTranslators(translatorid: number): Observable<Rate> {
        let url_ = this.baseUrl + "/api/Rate/GetTheAvrRateByEntityIdForTranslators/{translatorid}";
        if (translatorid === undefined || translatorid === null)
            throw new Error("The parameter 'translatorid' must be defined.");
        url_ = url_.replace("{translatorid}", encodeURIComponent("" + translatorid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTheAvrRateByEntityIdForTranslators(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTheAvrRateByEntityIdForTranslators(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Rate>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Rate>;
        }));
    }

    protected processGetTheAvrRateByEntityIdForTranslators(response: HttpResponseBase): Observable<Rate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Rate.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTheAvrRateByEntityIdForUser(userid: number): Observable<Rate> {
        let url_ = this.baseUrl + "/api/Rate/GetTheAvrRateByEntityIdForUser/{userid}";
        if (userid === undefined || userid === null)
            throw new Error("The parameter 'userid' must be defined.");
        url_ = url_.replace("{userid}", encodeURIComponent("" + userid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTheAvrRateByEntityIdForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTheAvrRateByEntityIdForUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Rate>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Rate>;
        }));
    }

    protected processGetTheAvrRateByEntityIdForUser(response: HttpResponseBase): Observable<Rate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Rate.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTheAvrRateByEntityIdForBook(bookid: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Rate/GetTheAvrRateByEntityIdForBook/{bookid}";
        if (bookid === undefined || bookid === null)
            throw new Error("The parameter 'bookid' must be defined.");
        url_ = url_.replace("{bookid}", encodeURIComponent("" + bookid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTheAvrRateByEntityIdForBook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTheAvrRateByEntityIdForBook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetTheAvrRateByEntityIdForBook(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRateByEntityIdandEntityType(entitytype: number, entityid: number): Observable<Rate> {
        let url_ = this.baseUrl + "/api/Rate/GetRateByEntityIdandEntityType/{entitytype}/{entityid}";
        if (entitytype === undefined || entitytype === null)
            throw new Error("The parameter 'entitytype' must be defined.");
        url_ = url_.replace("{entitytype}", encodeURIComponent("" + entitytype));
        if (entityid === undefined || entityid === null)
            throw new Error("The parameter 'entityid' must be defined.");
        url_ = url_.replace("{entityid}", encodeURIComponent("" + entityid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRateByEntityIdandEntityType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRateByEntityIdandEntityType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Rate>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Rate>;
        }));
    }

    protected processGetRateByEntityIdandEntityType(response: HttpResponseBase): Observable<Rate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Rate.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRate(getrate: GetRateSendViewModel): Observable<Rate> {
        let url_ = this.baseUrl + "/api/Rate/GetRate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(getrate);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Rate>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Rate>;
        }));
    }

    protected processGetRate(response: HttpResponseBase): Observable<Rate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Rate.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRateById(id: number): Observable<Rate> {
        let url_ = this.baseUrl + "/api/Rate/GetRateById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRateById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRateById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Rate>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Rate>;
        }));
    }

    protected processGetRateById(response: HttpResponseBase): Observable<Rate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Rate.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addRate(rate: RateViewModel): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Rate/AddRate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rate);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddRate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ReviewClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    getAll(): Observable<Review> {
        let url_ = this.baseUrl + "/api/Review/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Review>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Review>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Review> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Review.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: number): Observable<Review> {
        let url_ = this.baseUrl + "/api/Review/GetById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Review>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Review>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Review> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Review.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addReview(reviewvm: ReviewAddViewModel): Observable<number> {
        let url_ = this.baseUrl + "/api/Review/AddReview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reviewvm);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddReview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAddReview(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateReview(review: ReviewUpdateViewModel): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Review/UpdateReview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(review);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateReview(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Review/Delete/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TranslatorClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    getList(filterModel: TranslatorGetListFilterViewModel): Observable<PagedResponseOfListOfTranslatorGetListViewModel> {
        let url_ = this.baseUrl + "/api/Translator/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfListOfTranslatorGetListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfListOfTranslatorGetListViewModel>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<PagedResponseOfListOfTranslatorGetListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfListOfTranslatorGetListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllTranslators(): Observable<Translator[]> {
        let url_ = this.baseUrl + "/api/Translator/GetAllTranslators";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTranslators(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTranslators(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Translator[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Translator[]>;
        }));
    }

    protected processGetAllTranslators(response: HttpResponseBase): Observable<Translator[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Translator.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTranslatorById(id: number): Observable<Translator> {
        let url_ = this.baseUrl + "/api/Translator/GetTranslatorById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTranslatorById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTranslatorById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Translator>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Translator>;
        }));
    }

    protected processGetTranslatorById(response: HttpResponseBase): Observable<Translator> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Translator.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addTranslator(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Translator/AddTranslator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTranslator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTranslator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddTranslator(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTranslator(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Translator/UpdateTranslator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTranslator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTranslator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateTranslator(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTranslator(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Translator/DeleteTranslator/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTranslator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTranslator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteTranslator(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteImage(userId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Translator/DeleteImage?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteImage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProfilePicture(userId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Translator/GetProfilePicture/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getThumbnailProfilePicture(userId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Translator/GetThumbnailProfilePicture/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThumbnailProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThumbnailProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetThumbnailProfilePicture(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getThumbnailProfilePictureByName(fileName: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Translator/GetThumbnailProfilePictureByName/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThumbnailProfilePictureByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThumbnailProfilePictureByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetThumbnailProfilePictureByName(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProfilePictureByName(fileName: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Translator/GetProfilePictureByName/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProfilePictureByName(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserBookClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    getbyBookid(bookid: number | undefined): Observable<UserBook> {
        let url_ = this.baseUrl + "/api/UserBook/GetbyBookid?";
        if (bookid === null)
            throw new Error("The parameter 'bookid' cannot be null.");
        else if (bookid !== undefined)
            url_ += "bookid=" + encodeURIComponent("" + bookid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyBookid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyBookid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserBook>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserBook>;
        }));
    }

    protected processGetbyBookid(response: HttpResponseBase): Observable<UserBook> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBook.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByBookIdAndUserId(bookid: number | undefined): Observable<UserBook> {
        let url_ = this.baseUrl + "/api/UserBook/GetByBookIdAndUserId?";
        if (bookid === null)
            throw new Error("The parameter 'bookid' cannot be null.");
        else if (bookid !== undefined)
            url_ += "bookid=" + encodeURIComponent("" + bookid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByBookIdAndUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByBookIdAndUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserBook>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserBook>;
        }));
    }

    protected processGetByBookIdAndUserId(response: HttpResponseBase): Observable<UserBook> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBook.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllByUserId(): Observable<UserBook[]> {
        let url_ = this.baseUrl + "/api/UserBook/GetAllByUserId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserBook[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserBook[]>;
        }));
    }

    protected processGetAllByUserId(response: HttpResponseBase): Observable<UserBook[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserBook.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getlibrarybyuserid(): Observable<Book[]> {
        let url_ = this.baseUrl + "/api/UserBook/Getlibrarybyuserid";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlibrarybyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlibrarybyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Book[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Book[]>;
        }));
    }

    protected processGetlibrarybyuserid(response: HttpResponseBase): Observable<Book[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Book.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserBookMarksByUserid(): Observable<Book[]> {
        let url_ = this.baseUrl + "/api/UserBook/GetUserBookMarksByUserid";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserBookMarksByUserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserBookMarksByUserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Book[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Book[]>;
        }));
    }

    protected processGetUserBookMarksByUserid(response: HttpResponseBase): Observable<Book[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Book.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addToLibrary(bookid: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserBook/AddToLibrary?";
        if (bookid === null)
            throw new Error("The parameter 'bookid' cannot be null.");
        else if (bookid !== undefined)
            url_ += "bookid=" + encodeURIComponent("" + bookid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddToLibrary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddToLibrary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddToLibrary(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addToBookMarks(bookid: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserBook/AddToBookMarks?";
        if (bookid === null)
            throw new Error("The parameter 'bookid' cannot be null.");
        else if (bookid !== undefined)
            url_ += "bookid=" + encodeURIComponent("" + bookid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddToBookMarks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddToBookMarks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddToBookMarks(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteFromLibrary(bookid: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserBook/DeleteFromLibrary?";
        if (bookid === null)
            throw new Error("The parameter 'bookid' cannot be null.");
        else if (bookid !== undefined)
            url_ += "bookid=" + encodeURIComponent("" + bookid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFromLibrary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFromLibrary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteFromLibrary(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteFromBookMarks(bookid: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserBook/DeleteFromBookMarks?";
        if (bookid === null)
            throw new Error("The parameter 'bookid' cannot be null.");
        else if (bookid !== undefined)
            url_ += "bookid=" + encodeURIComponent("" + bookid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFromBookMarks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFromBookMarks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteFromBookMarks(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TransactionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    getDeposits(data: TransactionFilterViewModel): Observable<PagedResponseOfListOfGetDepositResultViewModel> {
        let url_ = this.baseUrl + "/api/Transaction/GetDeposits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeposits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeposits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfListOfGetDepositResultViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfListOfGetDepositResultViewModel>;
        }));
    }

    protected processGetDeposits(response: HttpResponseBase): Observable<PagedResponseOfListOfGetDepositResultViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfListOfGetDepositResultViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDepositRequests(): Observable<DepositRequest[]> {
        let url_ = this.baseUrl + "/api/Transaction/GetDepositRequests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepositRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepositRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepositRequest[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepositRequest[]>;
        }));
    }

    protected processGetDepositRequests(response: HttpResponseBase): Observable<DepositRequest[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DepositRequest.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    depositRequest(data: DepositRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Transaction/DepositRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDepositRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDepositRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDepositRequest(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    fastDeposit(userId: number | undefined, amount: number | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Transaction/FastDeposit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFastDeposit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFastDeposit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processFastDeposit(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    fastDebit(userId: number | undefined, amount: number | undefined, comment: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Transaction/FastDebit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFastDebit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFastDebit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processFastDebit(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTransactionReport(data: GetTransactionReportFilterViewModel): Observable<PagedResponseOfListOfGetTransactionReportViewModel> {
        let url_ = this.baseUrl + "/api/Transaction/GetTransactionReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfListOfGetTransactionReportViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfListOfGetTransactionReportViewModel>;
        }));
    }

    protected processGetTransactionReport(response: HttpResponseBase): Observable<PagedResponseOfListOfGetTransactionReportViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfListOfGetTransactionReportViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserTransactions(data: TransactionFilterViewModel): Observable<PagedResponseOfListOfTransactionInfoViewModel> {
        let url_ = this.baseUrl + "/api/Transaction/GetUserTransactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfListOfTransactionInfoViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfListOfTransactionInfoViewModel>;
        }));
    }

    protected processGetUserTransactions(response: HttpResponseBase): Observable<PagedResponseOfListOfTransactionInfoViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfListOfTransactionInfoViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getActiveGateway(): Observable<GatewayViewModel[]> {
        let url_ = this.baseUrl + "/api/Transaction/GetActiveGateway";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveGateway(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateway(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GatewayViewModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GatewayViewModel[]>;
        }));
    }

    protected processGetActiveGateway(response: HttpResponseBase): Observable<GatewayViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GatewayViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    register(data: RegisterViewModel): Observable<LoginResultViewModel> {
        let url_ = this.baseUrl + "/api/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResultViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResultViewModel>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<LoginResultViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResultViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(model: LoginViewModel): Observable<LoginResultViewModel> {
        let url_ = this.baseUrl + "/api/Account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResultViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResultViewModel>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResultViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResultViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    panelLogin(model: LoginViewModel): Observable<PanelLoginResultViewModel> {
        let url_ = this.baseUrl + "/api/Account/PanelLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPanelLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPanelLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PanelLoginResultViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PanelLoginResultViewModel>;
        }));
    }

    protected processPanelLogin(response: HttpResponseBase): Observable<PanelLoginResultViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PanelLoginResultViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshToken(model: Token): Observable<RefreshTokenViewModel> {
        let url_ = this.baseUrl + "/api/Account/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefreshTokenViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefreshTokenViewModel>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshTokenViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    logout(refreshToken: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/Logout?";
        if (refreshToken !== undefined && refreshToken !== null)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    forgetPassword(userName: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Account/ForgetPassword?";
        if (userName !== undefined && userName !== null)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processForgetPassword(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetPassword(data: ResetPasswordViewModel): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class MessageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    postMessage(data: PostMessageViewModel): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Message/PostMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processPostMessage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getNotification(data: PaginationData): Observable<PagedResponseOfListOfMessages> {
        let url_ = this.baseUrl + "/api/Message/GetNotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfListOfMessages>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfListOfMessages>;
        }));
    }

    protected processGetNotification(response: HttpResponseBase): Observable<PagedResponseOfListOfMessages> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfListOfMessages.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMessage(userId: number | undefined, data: PaginationData): Observable<PagedResponseOfListOfMessages> {
        let url_ = this.baseUrl + "/api/Message/GetMessage?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfListOfMessages>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfListOfMessages>;
        }));
    }

    protected processGetMessage(response: HttpResponseBase): Observable<PagedResponseOfListOfMessages> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfListOfMessages.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    readNotification(notificationId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Message/ReadNotification?";
        if (notificationId === null)
            throw new Error("The parameter 'notificationId' cannot be null.");
        else if (notificationId !== undefined)
            url_ += "notificationId=" + encodeURIComponent("" + notificationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processReadNotification(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    editMessage(data: Messages): Observable<Messages> {
        let url_ = this.baseUrl + "/api/Message/EditMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Messages>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Messages>;
        }));
    }

    protected processEditMessage(response: HttpResponseBase): Observable<Messages> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Messages.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMessage(messageId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Message/DeleteMessage?";
        if (messageId === null)
            throw new Error("The parameter 'messageId' cannot be null.");
        else if (messageId !== undefined)
            url_ += "messageId=" + encodeURIComponent("" + messageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteMessage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class RoleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    getRoleList(): Observable<Role[]> {
        let url_ = this.baseUrl + "/api/Role/GetRoleList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Role[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Role[]>;
        }));
    }

    protected processGetRoleList(response: HttpResponseBase): Observable<Role[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Role.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addRole(data: Role): Observable<Role> {
        let url_ = this.baseUrl + "/api/Role/AddRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Role>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Role>;
        }));
    }

    protected processAddRole(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    editRole(data: Role): Observable<Role> {
        let url_ = this.baseUrl + "/api/Role/EditRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Role>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Role>;
        }));
    }

    protected processEditRole(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getResourcesList(): Observable<Resources[]> {
        let url_ = this.baseUrl + "/api/Role/GetResourcesList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResourcesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResourcesList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Resources[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Resources[]>;
        }));
    }

    protected processGetResourcesList(response: HttpResponseBase): Observable<Resources[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Resources.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAccessibleResources(roleId: number): Observable<AccessibleResourceViewModel[]> {
        let url_ = this.baseUrl + "/api/Role/GetAccessibleResources/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessibleResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessibleResources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessibleResourceViewModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessibleResourceViewModel[]>;
        }));
    }

    protected processGetAccessibleResources(response: HttpResponseBase): Observable<AccessibleResourceViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AccessibleResourceViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setRolePolicy(data: SetRolePolicyViewModel): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Role/SetRolePolicy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetRolePolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetRolePolicy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSetRolePolicy(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    token(login: LoginViewModel): Observable<string> {
        let url_ = this.baseUrl + "/api/Token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processToken(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    getList(filterModel: UserGetListFilterViewModel): Observable<PagedResponseOfListOfUserGetListViewModel> {
        let url_ = this.baseUrl + "/api/User/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfListOfUserGetListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfListOfUserGetListViewModel>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<PagedResponseOfListOfUserGetListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfListOfUserGetListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPanelProfileInfo(): Observable<PanelInfoViewModel> {
        let url_ = this.baseUrl + "/api/User/GetPanelProfileInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPanelProfileInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPanelProfileInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PanelInfoViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PanelInfoViewModel>;
        }));
    }

    protected processGetPanelProfileInfo(response: HttpResponseBase): Observable<PanelInfoViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PanelInfoViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: number): Observable<UserViewModel> {
        let url_ = this.baseUrl + "/api/User/GetById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserViewModel>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<UserViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    profileInfo(): Observable<ProfileInfoViewModel> {
        let url_ = this.baseUrl + "/api/User/ProfileInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfileInfoViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfileInfoViewModel>;
        }));
    }

    protected processProfileInfo(response: HttpResponseBase): Observable<ProfileInfoViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfileInfoViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setProfileOtherProfileInfo(data: ProfileInfoViewModel): Observable<ProfileInfoViewModel> {
        let url_ = this.baseUrl + "/api/User/SetProfileOtherProfileInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetProfileOtherProfileInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetProfileOtherProfileInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfileInfoViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfileInfoViewModel>;
        }));
    }

    protected processSetProfileOtherProfileInfo(response: HttpResponseBase): Observable<ProfileInfoViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfileInfoViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setProfileInfo(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/SetProfileInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetProfileInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetProfileInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSetProfileInfo(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setProfileImage(userImage: FileParameter): Observable<string> {
        let url_ = this.baseUrl + "/api/User/SetProfileImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (userImage === null || userImage === undefined)
            throw new Error("The parameter 'userImage' cannot be null.");
        else
            content_.append("userImage", userImage.data, userImage.fileName ? userImage.fileName : "userImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetProfileImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetProfileImage(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSetProfileImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadImage(contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: IHeaderDictionary | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteImage(userId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/DeleteImage?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteImage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProfilePicture(userId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/User/GetProfilePicture/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getThumbnailProfilePicture(userId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/User/GetThumbnailProfilePicture/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThumbnailProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThumbnailProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetThumbnailProfilePicture(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getThumbnailProfilePictureByName(fileName: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/User/GetThumbnailProfilePictureByName/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThumbnailProfilePictureByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThumbnailProfilePictureByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetThumbnailProfilePictureByName(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProfilePictureByName(fileName: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/User/GetProfilePictureByName/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProfilePictureByName(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changePassword(data: ChangePasswordViewModel): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    adminChangePassword(userId: number | undefined, newPassword: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/AdminChangePassword?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (newPassword !== undefined && newPassword !== null)
            url_ += "newPassword=" + encodeURIComponent("" + newPassword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addUser(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/AddUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateUserInfo(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/UpdateUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateUserInfo(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    userVerificationRequest(data: UserVerificationRequestViewModel): Observable<UserVerificationRequestResultViewModel> {
        let url_ = this.baseUrl + "/api/User/UserVerificationRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserVerificationRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserVerificationRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserVerificationRequestResultViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserVerificationRequestResultViewModel>;
        }));
    }

    protected processUserVerificationRequest(response: HttpResponseBase): Observable<UserVerificationRequestResultViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserVerificationRequestResultViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    userVerificationByCode(data: UserVerificationViewModel): Observable<UserVerificationRequestResultViewModel> {
        let url_ = this.baseUrl + "/api/User/UserVerificationByCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserVerificationByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserVerificationByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserVerificationRequestResultViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserVerificationRequestResultViewModel>;
        }));
    }

    protected processUserVerificationByCode(response: HttpResponseBase): Observable<UserVerificationRequestResultViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserVerificationRequestResultViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserInviteList(filterModel: InviteHistoryFilterViewModel): Observable<PagedResponseOfListOfInviteHistoryViewModel> {
        let url_ = this.baseUrl + "/api/User/GetUserInviteList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInviteList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInviteList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfListOfInviteHistoryViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfListOfInviteHistoryViewModel>;
        }));
    }

    protected processGetUserInviteList(response: HttpResponseBase): Observable<PagedResponseOfListOfInviteHistoryViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfListOfInviteHistoryViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CommonClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    /**
     * @param userImage User Image
     */
    addImage(userImage: FileParameter): Observable<KeyValueViewModel> {
        let url_ = this.baseUrl + "/api/Common/AddImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (userImage === null || userImage === undefined)
            throw new Error("The parameter 'userImage' cannot be null.");
        else
            content_.append("userImage", userImage.data, userImage.fileName ? userImage.fileName : "userImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KeyValueViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KeyValueViewModel>;
        }));
    }

    protected processAddImage(response: HttpResponseBase): Observable<KeyValueViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KeyValueViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserImage(fileName: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Common/GetUserImage/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetUserImage(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getImageById(imageId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Common/GetImageById/{imageId}";
        if (imageId === undefined || imageId === null)
            throw new Error("The parameter 'imageId' must be defined.");
        url_ = url_.replace("{imageId}", encodeURIComponent("" + imageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImageById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImageById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetImageById(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getThumbnailImageById(imageId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Common/GetThumbnailImageById/{imageId}";
        if (imageId === undefined || imageId === null)
            throw new Error("The parameter 'imageId' must be defined.");
        url_ = url_.replace("{imageId}", encodeURIComponent("" + imageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThumbnailImageById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThumbnailImageById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetThumbnailImageById(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLogList(filterModel: LogFilterViewModel): Observable<PagedResponseOfListOfLogResponseViewModel> {
        let url_ = this.baseUrl + "/api/Common/GetLogList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfListOfLogResponseViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfListOfLogResponseViewModel>;
        }));
    }

    protected processGetLogList(response: HttpResponseBase): Observable<PagedResponseOfListOfLogResponseViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResponseOfListOfLogResponseViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class EmailClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7254";
    }

    getList(): Observable<EmailTemplate[]> {
        let url_ = this.baseUrl + "/api/Email/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmailTemplate[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmailTemplate[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<EmailTemplate[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmailTemplate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: number): Observable<EmailTemplate> {
        let url_ = this.baseUrl + "/api/Email/GetById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmailTemplate>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmailTemplate>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<EmailTemplate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailTemplate.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    add(data: EmailTemplate): Observable<number> {
        let url_ = this.baseUrl + "/api/Email/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    edit(data: EmailTemplate): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Email/Edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processEdit(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Email/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    send(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Email/Send/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSend(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class BookViewModel implements IBookViewModel {
    bookName?: string | undefined;
    publisher?: string | undefined;
    yearOfPublication?: Date;
    bookFormat?: number;
    bookType?: number;
    numberOfPages?: number;
    language?: string | undefined;
    isbn?: number;
    electronicVersionPrice?: number;
    bookPictureName?: string | undefined;
    isActive?: boolean;
    isDeleted?: boolean;
    isModified?: boolean;
    lastModified?: Date | undefined;
    createOn?: Date | undefined;
    author?: Dropdownget[] | undefined;
    translator?: Dropdownget[] | undefined;
    subjects?: Dropdownget[] | undefined;
    category?: Dropdownget[] | undefined;

    constructor(data?: IBookViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookName = _data["bookName"];
            this.publisher = _data["publisher"];
            this.yearOfPublication = _data["yearOfPublication"] ? new Date(_data["yearOfPublication"].toString()) : <any>undefined;
            this.bookFormat = _data["bookFormat"];
            this.bookType = _data["bookType"];
            this.numberOfPages = _data["numberOfPages"];
            this.language = _data["language"];
            this.isbn = _data["isbn"];
            this.electronicVersionPrice = _data["electronicVersionPrice"];
            this.bookPictureName = _data["bookPictureName"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isModified = _data["isModified"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.createOn = _data["createOn"] ? new Date(_data["createOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["author"])) {
                this.author = [] as any;
                for (let item of _data["author"])
                    this.author!.push(Dropdownget.fromJS(item));
            }
            if (Array.isArray(_data["translator"])) {
                this.translator = [] as any;
                for (let item of _data["translator"])
                    this.translator!.push(Dropdownget.fromJS(item));
            }
            if (Array.isArray(_data["subjects"])) {
                this.subjects = [] as any;
                for (let item of _data["subjects"])
                    this.subjects!.push(Dropdownget.fromJS(item));
            }
            if (Array.isArray(_data["category"])) {
                this.category = [] as any;
                for (let item of _data["category"])
                    this.category!.push(Dropdownget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BookViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new BookViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookName"] = this.bookName;
        data["publisher"] = this.publisher;
        data["yearOfPublication"] = this.yearOfPublication ? this.yearOfPublication.toISOString() : <any>undefined;
        data["bookFormat"] = this.bookFormat;
        data["bookType"] = this.bookType;
        data["numberOfPages"] = this.numberOfPages;
        data["language"] = this.language;
        data["isbn"] = this.isbn;
        data["electronicVersionPrice"] = this.electronicVersionPrice;
        data["bookPictureName"] = this.bookPictureName;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isModified"] = this.isModified;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["createOn"] = this.createOn ? this.createOn.toISOString() : <any>undefined;
        if (Array.isArray(this.author)) {
            data["author"] = [];
            for (let item of this.author)
                data["author"].push(item.toJSON());
        }
        if (Array.isArray(this.translator)) {
            data["translator"] = [];
            for (let item of this.translator)
                data["translator"].push(item.toJSON());
        }
        if (Array.isArray(this.subjects)) {
            data["subjects"] = [];
            for (let item of this.subjects)
                data["subjects"].push(item.toJSON());
        }
        if (Array.isArray(this.category)) {
            data["category"] = [];
            for (let item of this.category)
                data["category"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBookViewModel {
    bookName?: string | undefined;
    publisher?: string | undefined;
    yearOfPublication?: Date;
    bookFormat?: number;
    bookType?: number;
    numberOfPages?: number;
    language?: string | undefined;
    isbn?: number;
    electronicVersionPrice?: number;
    bookPictureName?: string | undefined;
    isActive?: boolean;
    isDeleted?: boolean;
    isModified?: boolean;
    lastModified?: Date | undefined;
    createOn?: Date | undefined;
    author?: Dropdownget[] | undefined;
    translator?: Dropdownget[] | undefined;
    subjects?: Dropdownget[] | undefined;
    category?: Dropdownget[] | undefined;
}

export class Dropdownget implements IDropdownget {
    authorId?: number;
    translatorId?: number;
    categoryId?: number;
    subjectId?: number;
    subjectTitle?: string | undefined;
    categoryTitle?: string | undefined;
    authorFirstName?: string | undefined;
    translatorFirstName?: string | undefined;
    authorLastName?: string | undefined;
    translatorLastName?: string | undefined;

    constructor(data?: IDropdownget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authorId = _data["authorId"];
            this.translatorId = _data["translatorId"];
            this.categoryId = _data["categoryId"];
            this.subjectId = _data["subjectId"];
            this.subjectTitle = _data["subjectTitle"];
            this.categoryTitle = _data["categoryTitle"];
            this.authorFirstName = _data["authorFirstName"];
            this.translatorFirstName = _data["translatorFirstName"];
            this.authorLastName = _data["authorLastName"];
            this.translatorLastName = _data["translatorLastName"];
        }
    }

    static fromJS(data: any): Dropdownget {
        data = typeof data === 'object' ? data : {};
        let result = new Dropdownget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authorId"] = this.authorId;
        data["translatorId"] = this.translatorId;
        data["categoryId"] = this.categoryId;
        data["subjectId"] = this.subjectId;
        data["subjectTitle"] = this.subjectTitle;
        data["categoryTitle"] = this.categoryTitle;
        data["authorFirstName"] = this.authorFirstName;
        data["translatorFirstName"] = this.translatorFirstName;
        data["authorLastName"] = this.authorLastName;
        data["translatorLastName"] = this.translatorLastName;
        return data;
    }
}

export interface IDropdownget {
    authorId?: number;
    translatorId?: number;
    categoryId?: number;
    subjectId?: number;
    subjectTitle?: string | undefined;
    categoryTitle?: string | undefined;
    authorFirstName?: string | undefined;
    translatorFirstName?: string | undefined;
    authorLastName?: string | undefined;
    translatorLastName?: string | undefined;
}

export class ResponseOfListOfBookListViewModel implements IResponseOfListOfBookListViewModel {
    data?: BookListViewModel[];

    constructor(data?: IResponseOfListOfBookListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(BookListViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseOfListOfBookListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfListOfBookListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseOfListOfBookListViewModel {
    data?: BookListViewModel[];
}

export class PagedResponseOfListOfBookListViewModel extends ResponseOfListOfBookListViewModel implements IPagedResponseOfListOfBookListViewModel {
    totalRecords?: number;

    constructor(data?: IPagedResponseOfListOfBookListViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): PagedResponseOfListOfBookListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfListOfBookListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRecords"] = this.totalRecords;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResponseOfListOfBookListViewModel extends IResponseOfListOfBookListViewModel {
    totalRecords?: number;
}

export class BookListViewModel implements IBookListViewModel {
    id?: number;
    bookName?: string | undefined;
    author?: string | undefined;
    translator?: string | undefined;
    publisher?: string | undefined;
    yearOfPublication?: Date;
    bookFormat?: number;
    bookType?: number;
    numberOfPages?: number;
    language?: string | undefined;
    isbn?: number;
    bookSubject?: string | undefined;
    electronicVersionPrice?: number;
    bookPictureName?: string | undefined;
    isActive?: boolean;
    isDeleted?: boolean;
    isModified?: boolean;
    modifierId?: number | undefined;
    lastModified?: Date | undefined;
    createOn?: Date | undefined;

    constructor(data?: IBookListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bookName = _data["bookName"];
            this.author = _data["author"];
            this.translator = _data["translator"];
            this.publisher = _data["publisher"];
            this.yearOfPublication = _data["yearOfPublication"] ? new Date(_data["yearOfPublication"].toString()) : <any>undefined;
            this.bookFormat = _data["bookFormat"];
            this.bookType = _data["bookType"];
            this.numberOfPages = _data["numberOfPages"];
            this.language = _data["language"];
            this.isbn = _data["isbn"];
            this.bookSubject = _data["bookSubject"];
            this.electronicVersionPrice = _data["electronicVersionPrice"];
            this.bookPictureName = _data["bookPictureName"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isModified = _data["isModified"];
            this.modifierId = _data["modifierId"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.createOn = _data["createOn"] ? new Date(_data["createOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BookListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new BookListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bookName"] = this.bookName;
        data["author"] = this.author;
        data["translator"] = this.translator;
        data["publisher"] = this.publisher;
        data["yearOfPublication"] = this.yearOfPublication ? this.yearOfPublication.toISOString() : <any>undefined;
        data["bookFormat"] = this.bookFormat;
        data["bookType"] = this.bookType;
        data["numberOfPages"] = this.numberOfPages;
        data["language"] = this.language;
        data["isbn"] = this.isbn;
        data["bookSubject"] = this.bookSubject;
        data["electronicVersionPrice"] = this.electronicVersionPrice;
        data["bookPictureName"] = this.bookPictureName;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isModified"] = this.isModified;
        data["modifierId"] = this.modifierId;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["createOn"] = this.createOn ? this.createOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBookListViewModel {
    id?: number;
    bookName?: string | undefined;
    author?: string | undefined;
    translator?: string | undefined;
    publisher?: string | undefined;
    yearOfPublication?: Date;
    bookFormat?: number;
    bookType?: number;
    numberOfPages?: number;
    language?: string | undefined;
    isbn?: number;
    bookSubject?: string | undefined;
    electronicVersionPrice?: number;
    bookPictureName?: string | undefined;
    isActive?: boolean;
    isDeleted?: boolean;
    isModified?: boolean;
    modifierId?: number | undefined;
    lastModified?: Date | undefined;
    createOn?: Date | undefined;
}

export class BookGetListFilterViewModel implements IBookGetListFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    authorId?: number | undefined;
    bookName?: string | undefined;
    author?: string | undefined;
    translator?: string | undefined;
    publisher?: string | undefined;
    yearOfPublication?: Date | undefined;
    bookFormat?: number | undefined;
    bookType?: number | undefined;
    numberOfPages?: number | undefined;
    language?: string | undefined;
    bookSubject?: string | undefined;
    electronicVersionPrice?: number | undefined;
    isActive?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isModified?: boolean | undefined;
    lastModified?: Date | undefined;
    createOn?: Date | undefined;

    constructor(data?: IBookGetListFilterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.authorId = _data["authorId"];
            this.bookName = _data["bookName"];
            this.author = _data["author"];
            this.translator = _data["translator"];
            this.publisher = _data["publisher"];
            this.yearOfPublication = _data["yearOfPublication"] ? new Date(_data["yearOfPublication"].toString()) : <any>undefined;
            this.bookFormat = _data["bookFormat"];
            this.bookType = _data["bookType"];
            this.numberOfPages = _data["numberOfPages"];
            this.language = _data["language"];
            this.bookSubject = _data["bookSubject"];
            this.electronicVersionPrice = _data["electronicVersionPrice"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isModified = _data["isModified"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.createOn = _data["createOn"] ? new Date(_data["createOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BookGetListFilterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new BookGetListFilterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["authorId"] = this.authorId;
        data["bookName"] = this.bookName;
        data["author"] = this.author;
        data["translator"] = this.translator;
        data["publisher"] = this.publisher;
        data["yearOfPublication"] = this.yearOfPublication ? this.yearOfPublication.toISOString() : <any>undefined;
        data["bookFormat"] = this.bookFormat;
        data["bookType"] = this.bookType;
        data["numberOfPages"] = this.numberOfPages;
        data["language"] = this.language;
        data["bookSubject"] = this.bookSubject;
        data["electronicVersionPrice"] = this.electronicVersionPrice;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isModified"] = this.isModified;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["createOn"] = this.createOn ? this.createOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBookGetListFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    authorId?: number | undefined;
    bookName?: string | undefined;
    author?: string | undefined;
    translator?: string | undefined;
    publisher?: string | undefined;
    yearOfPublication?: Date | undefined;
    bookFormat?: number | undefined;
    bookType?: number | undefined;
    numberOfPages?: number | undefined;
    language?: string | undefined;
    bookSubject?: string | undefined;
    electronicVersionPrice?: number | undefined;
    isActive?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isModified?: boolean | undefined;
    lastModified?: Date | undefined;
    createOn?: Date | undefined;
}

export class Author implements IAuthor {
    id?: number;
    authorFirstName?: string | undefined;
    authorLastName?: string | undefined;
    profilePictureId?: number | undefined;
    profilePictureName?: string | undefined;
    birthday?: Date;
    country?: string | undefined;
    language?: string | undefined;
    age?: number;
    bio?: string | undefined;

    constructor(data?: IAuthor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.authorFirstName = _data["authorFirstName"];
            this.authorLastName = _data["authorLastName"];
            this.profilePictureId = _data["profilePictureId"];
            this.profilePictureName = _data["profilePictureName"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.country = _data["country"];
            this.language = _data["language"];
            this.age = _data["age"];
            this.bio = _data["bio"];
        }
    }

    static fromJS(data: any): Author {
        data = typeof data === 'object' ? data : {};
        let result = new Author();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["authorFirstName"] = this.authorFirstName;
        data["authorLastName"] = this.authorLastName;
        data["profilePictureId"] = this.profilePictureId;
        data["profilePictureName"] = this.profilePictureName;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["country"] = this.country;
        data["language"] = this.language;
        data["age"] = this.age;
        data["bio"] = this.bio;
        return data;
    }
}

export interface IAuthor {
    id?: number;
    authorFirstName?: string | undefined;
    authorLastName?: string | undefined;
    profilePictureId?: number | undefined;
    profilePictureName?: string | undefined;
    birthday?: Date;
    country?: string | undefined;
    language?: string | undefined;
    age?: number;
    bio?: string | undefined;
}

export abstract class IHeaderDictionary implements IIHeaderDictionary {
    item?: any[];
    contentLength?: number | undefined;
    accept?: any[];
    acceptCharset?: any[];
    acceptEncoding?: any[];
    acceptLanguage?: any[];
    acceptRanges?: any[];
    accessControlAllowCredentials?: any[];
    accessControlAllowHeaders?: any[];
    accessControlAllowMethods?: any[];
    accessControlAllowOrigin?: any[];
    accessControlExposeHeaders?: any[];
    accessControlMaxAge?: any[];
    accessControlRequestHeaders?: any[];
    accessControlRequestMethod?: any[];
    age?: any[];
    allow?: any[];
    altSvc?: any[];
    authorization?: any[];
    baggage?: any[];
    cacheControl?: any[];
    connection?: any[];
    contentDisposition?: any[];
    contentEncoding?: any[];
    contentLanguage?: any[];
    contentLocation?: any[];
    contentMD5?: any[];
    contentRange?: any[];
    contentSecurityPolicy?: any[];
    contentSecurityPolicyReportOnly?: any[];
    contentType?: any[];
    correlationContext?: any[];
    cookie?: any[];
    date?: any[];
    eTag?: any[];
    expires?: any[];
    expect?: any[];
    from?: any[];
    grpcAcceptEncoding?: any[];
    grpcEncoding?: any[];
    grpcMessage?: any[];
    grpcStatus?: any[];
    grpcTimeout?: any[];
    host?: any[];
    keepAlive?: any[];
    ifMatch?: any[];
    ifModifiedSince?: any[];
    ifNoneMatch?: any[];
    ifRange?: any[];
    ifUnmodifiedSince?: any[];
    lastModified?: any[];
    link?: any[];
    location?: any[];
    maxForwards?: any[];
    origin?: any[];
    pragma?: any[];
    proxyAuthenticate?: any[];
    proxyAuthorization?: any[];
    proxyConnection?: any[];
    range?: any[];
    referer?: any[];
    retryAfter?: any[];
    requestId?: any[];
    secWebSocketAccept?: any[];
    secWebSocketKey?: any[];
    secWebSocketProtocol?: any[];
    secWebSocketVersion?: any[];
    secWebSocketExtensions?: any[];
    server?: any[];
    setCookie?: any[];
    strictTransportSecurity?: any[];
    tE?: any[];
    trailer?: any[];
    transferEncoding?: any[];
    translate?: any[];
    traceParent?: any[];
    traceState?: any[];
    upgrade?: any[];
    upgradeInsecureRequests?: any[];
    userAgent?: any[];
    vary?: any[];
    via?: any[];
    warning?: any[];
    webSocketSubProtocols?: any[];
    wWWAuthenticate?: any[];
    xContentTypeOptions?: any[];
    xFrameOptions?: any[];
    xPoweredBy?: any[];
    xRequestedWith?: any[];
    xUACompatible?: any[];
    xXSSProtection?: any[];

    constructor(data?: IIHeaderDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Item"])) {
                this.item = [] as any;
                for (let item of _data["Item"])
                    this.item!.push(item);
            }
            this.contentLength = _data["ContentLength"];
            if (Array.isArray(_data["Accept"])) {
                this.accept = [] as any;
                for (let item of _data["Accept"])
                    this.accept!.push(item);
            }
            if (Array.isArray(_data["AcceptCharset"])) {
                this.acceptCharset = [] as any;
                for (let item of _data["AcceptCharset"])
                    this.acceptCharset!.push(item);
            }
            if (Array.isArray(_data["AcceptEncoding"])) {
                this.acceptEncoding = [] as any;
                for (let item of _data["AcceptEncoding"])
                    this.acceptEncoding!.push(item);
            }
            if (Array.isArray(_data["AcceptLanguage"])) {
                this.acceptLanguage = [] as any;
                for (let item of _data["AcceptLanguage"])
                    this.acceptLanguage!.push(item);
            }
            if (Array.isArray(_data["AcceptRanges"])) {
                this.acceptRanges = [] as any;
                for (let item of _data["AcceptRanges"])
                    this.acceptRanges!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowCredentials"])) {
                this.accessControlAllowCredentials = [] as any;
                for (let item of _data["AccessControlAllowCredentials"])
                    this.accessControlAllowCredentials!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowHeaders"])) {
                this.accessControlAllowHeaders = [] as any;
                for (let item of _data["AccessControlAllowHeaders"])
                    this.accessControlAllowHeaders!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowMethods"])) {
                this.accessControlAllowMethods = [] as any;
                for (let item of _data["AccessControlAllowMethods"])
                    this.accessControlAllowMethods!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowOrigin"])) {
                this.accessControlAllowOrigin = [] as any;
                for (let item of _data["AccessControlAllowOrigin"])
                    this.accessControlAllowOrigin!.push(item);
            }
            if (Array.isArray(_data["AccessControlExposeHeaders"])) {
                this.accessControlExposeHeaders = [] as any;
                for (let item of _data["AccessControlExposeHeaders"])
                    this.accessControlExposeHeaders!.push(item);
            }
            if (Array.isArray(_data["AccessControlMaxAge"])) {
                this.accessControlMaxAge = [] as any;
                for (let item of _data["AccessControlMaxAge"])
                    this.accessControlMaxAge!.push(item);
            }
            if (Array.isArray(_data["AccessControlRequestHeaders"])) {
                this.accessControlRequestHeaders = [] as any;
                for (let item of _data["AccessControlRequestHeaders"])
                    this.accessControlRequestHeaders!.push(item);
            }
            if (Array.isArray(_data["AccessControlRequestMethod"])) {
                this.accessControlRequestMethod = [] as any;
                for (let item of _data["AccessControlRequestMethod"])
                    this.accessControlRequestMethod!.push(item);
            }
            if (Array.isArray(_data["Age"])) {
                this.age = [] as any;
                for (let item of _data["Age"])
                    this.age!.push(item);
            }
            if (Array.isArray(_data["Allow"])) {
                this.allow = [] as any;
                for (let item of _data["Allow"])
                    this.allow!.push(item);
            }
            if (Array.isArray(_data["AltSvc"])) {
                this.altSvc = [] as any;
                for (let item of _data["AltSvc"])
                    this.altSvc!.push(item);
            }
            if (Array.isArray(_data["Authorization"])) {
                this.authorization = [] as any;
                for (let item of _data["Authorization"])
                    this.authorization!.push(item);
            }
            if (Array.isArray(_data["Baggage"])) {
                this.baggage = [] as any;
                for (let item of _data["Baggage"])
                    this.baggage!.push(item);
            }
            if (Array.isArray(_data["CacheControl"])) {
                this.cacheControl = [] as any;
                for (let item of _data["CacheControl"])
                    this.cacheControl!.push(item);
            }
            if (Array.isArray(_data["Connection"])) {
                this.connection = [] as any;
                for (let item of _data["Connection"])
                    this.connection!.push(item);
            }
            if (Array.isArray(_data["ContentDisposition"])) {
                this.contentDisposition = [] as any;
                for (let item of _data["ContentDisposition"])
                    this.contentDisposition!.push(item);
            }
            if (Array.isArray(_data["ContentEncoding"])) {
                this.contentEncoding = [] as any;
                for (let item of _data["ContentEncoding"])
                    this.contentEncoding!.push(item);
            }
            if (Array.isArray(_data["ContentLanguage"])) {
                this.contentLanguage = [] as any;
                for (let item of _data["ContentLanguage"])
                    this.contentLanguage!.push(item);
            }
            if (Array.isArray(_data["ContentLocation"])) {
                this.contentLocation = [] as any;
                for (let item of _data["ContentLocation"])
                    this.contentLocation!.push(item);
            }
            if (Array.isArray(_data["ContentMD5"])) {
                this.contentMD5 = [] as any;
                for (let item of _data["ContentMD5"])
                    this.contentMD5!.push(item);
            }
            if (Array.isArray(_data["ContentRange"])) {
                this.contentRange = [] as any;
                for (let item of _data["ContentRange"])
                    this.contentRange!.push(item);
            }
            if (Array.isArray(_data["ContentSecurityPolicy"])) {
                this.contentSecurityPolicy = [] as any;
                for (let item of _data["ContentSecurityPolicy"])
                    this.contentSecurityPolicy!.push(item);
            }
            if (Array.isArray(_data["ContentSecurityPolicyReportOnly"])) {
                this.contentSecurityPolicyReportOnly = [] as any;
                for (let item of _data["ContentSecurityPolicyReportOnly"])
                    this.contentSecurityPolicyReportOnly!.push(item);
            }
            if (Array.isArray(_data["ContentType"])) {
                this.contentType = [] as any;
                for (let item of _data["ContentType"])
                    this.contentType!.push(item);
            }
            if (Array.isArray(_data["CorrelationContext"])) {
                this.correlationContext = [] as any;
                for (let item of _data["CorrelationContext"])
                    this.correlationContext!.push(item);
            }
            if (Array.isArray(_data["Cookie"])) {
                this.cookie = [] as any;
                for (let item of _data["Cookie"])
                    this.cookie!.push(item);
            }
            if (Array.isArray(_data["Date"])) {
                this.date = [] as any;
                for (let item of _data["Date"])
                    this.date!.push(item);
            }
            if (Array.isArray(_data["ETag"])) {
                this.eTag = [] as any;
                for (let item of _data["ETag"])
                    this.eTag!.push(item);
            }
            if (Array.isArray(_data["Expires"])) {
                this.expires = [] as any;
                for (let item of _data["Expires"])
                    this.expires!.push(item);
            }
            if (Array.isArray(_data["Expect"])) {
                this.expect = [] as any;
                for (let item of _data["Expect"])
                    this.expect!.push(item);
            }
            if (Array.isArray(_data["From"])) {
                this.from = [] as any;
                for (let item of _data["From"])
                    this.from!.push(item);
            }
            if (Array.isArray(_data["GrpcAcceptEncoding"])) {
                this.grpcAcceptEncoding = [] as any;
                for (let item of _data["GrpcAcceptEncoding"])
                    this.grpcAcceptEncoding!.push(item);
            }
            if (Array.isArray(_data["GrpcEncoding"])) {
                this.grpcEncoding = [] as any;
                for (let item of _data["GrpcEncoding"])
                    this.grpcEncoding!.push(item);
            }
            if (Array.isArray(_data["GrpcMessage"])) {
                this.grpcMessage = [] as any;
                for (let item of _data["GrpcMessage"])
                    this.grpcMessage!.push(item);
            }
            if (Array.isArray(_data["GrpcStatus"])) {
                this.grpcStatus = [] as any;
                for (let item of _data["GrpcStatus"])
                    this.grpcStatus!.push(item);
            }
            if (Array.isArray(_data["GrpcTimeout"])) {
                this.grpcTimeout = [] as any;
                for (let item of _data["GrpcTimeout"])
                    this.grpcTimeout!.push(item);
            }
            if (Array.isArray(_data["Host"])) {
                this.host = [] as any;
                for (let item of _data["Host"])
                    this.host!.push(item);
            }
            if (Array.isArray(_data["KeepAlive"])) {
                this.keepAlive = [] as any;
                for (let item of _data["KeepAlive"])
                    this.keepAlive!.push(item);
            }
            if (Array.isArray(_data["IfMatch"])) {
                this.ifMatch = [] as any;
                for (let item of _data["IfMatch"])
                    this.ifMatch!.push(item);
            }
            if (Array.isArray(_data["IfModifiedSince"])) {
                this.ifModifiedSince = [] as any;
                for (let item of _data["IfModifiedSince"])
                    this.ifModifiedSince!.push(item);
            }
            if (Array.isArray(_data["IfNoneMatch"])) {
                this.ifNoneMatch = [] as any;
                for (let item of _data["IfNoneMatch"])
                    this.ifNoneMatch!.push(item);
            }
            if (Array.isArray(_data["IfRange"])) {
                this.ifRange = [] as any;
                for (let item of _data["IfRange"])
                    this.ifRange!.push(item);
            }
            if (Array.isArray(_data["IfUnmodifiedSince"])) {
                this.ifUnmodifiedSince = [] as any;
                for (let item of _data["IfUnmodifiedSince"])
                    this.ifUnmodifiedSince!.push(item);
            }
            if (Array.isArray(_data["LastModified"])) {
                this.lastModified = [] as any;
                for (let item of _data["LastModified"])
                    this.lastModified!.push(item);
            }
            if (Array.isArray(_data["Link"])) {
                this.link = [] as any;
                for (let item of _data["Link"])
                    this.link!.push(item);
            }
            if (Array.isArray(_data["Location"])) {
                this.location = [] as any;
                for (let item of _data["Location"])
                    this.location!.push(item);
            }
            if (Array.isArray(_data["MaxForwards"])) {
                this.maxForwards = [] as any;
                for (let item of _data["MaxForwards"])
                    this.maxForwards!.push(item);
            }
            if (Array.isArray(_data["Origin"])) {
                this.origin = [] as any;
                for (let item of _data["Origin"])
                    this.origin!.push(item);
            }
            if (Array.isArray(_data["Pragma"])) {
                this.pragma = [] as any;
                for (let item of _data["Pragma"])
                    this.pragma!.push(item);
            }
            if (Array.isArray(_data["ProxyAuthenticate"])) {
                this.proxyAuthenticate = [] as any;
                for (let item of _data["ProxyAuthenticate"])
                    this.proxyAuthenticate!.push(item);
            }
            if (Array.isArray(_data["ProxyAuthorization"])) {
                this.proxyAuthorization = [] as any;
                for (let item of _data["ProxyAuthorization"])
                    this.proxyAuthorization!.push(item);
            }
            if (Array.isArray(_data["ProxyConnection"])) {
                this.proxyConnection = [] as any;
                for (let item of _data["ProxyConnection"])
                    this.proxyConnection!.push(item);
            }
            if (Array.isArray(_data["Range"])) {
                this.range = [] as any;
                for (let item of _data["Range"])
                    this.range!.push(item);
            }
            if (Array.isArray(_data["Referer"])) {
                this.referer = [] as any;
                for (let item of _data["Referer"])
                    this.referer!.push(item);
            }
            if (Array.isArray(_data["RetryAfter"])) {
                this.retryAfter = [] as any;
                for (let item of _data["RetryAfter"])
                    this.retryAfter!.push(item);
            }
            if (Array.isArray(_data["RequestId"])) {
                this.requestId = [] as any;
                for (let item of _data["RequestId"])
                    this.requestId!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketAccept"])) {
                this.secWebSocketAccept = [] as any;
                for (let item of _data["SecWebSocketAccept"])
                    this.secWebSocketAccept!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketKey"])) {
                this.secWebSocketKey = [] as any;
                for (let item of _data["SecWebSocketKey"])
                    this.secWebSocketKey!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketProtocol"])) {
                this.secWebSocketProtocol = [] as any;
                for (let item of _data["SecWebSocketProtocol"])
                    this.secWebSocketProtocol!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketVersion"])) {
                this.secWebSocketVersion = [] as any;
                for (let item of _data["SecWebSocketVersion"])
                    this.secWebSocketVersion!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketExtensions"])) {
                this.secWebSocketExtensions = [] as any;
                for (let item of _data["SecWebSocketExtensions"])
                    this.secWebSocketExtensions!.push(item);
            }
            if (Array.isArray(_data["Server"])) {
                this.server = [] as any;
                for (let item of _data["Server"])
                    this.server!.push(item);
            }
            if (Array.isArray(_data["SetCookie"])) {
                this.setCookie = [] as any;
                for (let item of _data["SetCookie"])
                    this.setCookie!.push(item);
            }
            if (Array.isArray(_data["StrictTransportSecurity"])) {
                this.strictTransportSecurity = [] as any;
                for (let item of _data["StrictTransportSecurity"])
                    this.strictTransportSecurity!.push(item);
            }
            if (Array.isArray(_data["TE"])) {
                this.tE = [] as any;
                for (let item of _data["TE"])
                    this.tE!.push(item);
            }
            if (Array.isArray(_data["Trailer"])) {
                this.trailer = [] as any;
                for (let item of _data["Trailer"])
                    this.trailer!.push(item);
            }
            if (Array.isArray(_data["TransferEncoding"])) {
                this.transferEncoding = [] as any;
                for (let item of _data["TransferEncoding"])
                    this.transferEncoding!.push(item);
            }
            if (Array.isArray(_data["Translate"])) {
                this.translate = [] as any;
                for (let item of _data["Translate"])
                    this.translate!.push(item);
            }
            if (Array.isArray(_data["TraceParent"])) {
                this.traceParent = [] as any;
                for (let item of _data["TraceParent"])
                    this.traceParent!.push(item);
            }
            if (Array.isArray(_data["TraceState"])) {
                this.traceState = [] as any;
                for (let item of _data["TraceState"])
                    this.traceState!.push(item);
            }
            if (Array.isArray(_data["Upgrade"])) {
                this.upgrade = [] as any;
                for (let item of _data["Upgrade"])
                    this.upgrade!.push(item);
            }
            if (Array.isArray(_data["UpgradeInsecureRequests"])) {
                this.upgradeInsecureRequests = [] as any;
                for (let item of _data["UpgradeInsecureRequests"])
                    this.upgradeInsecureRequests!.push(item);
            }
            if (Array.isArray(_data["UserAgent"])) {
                this.userAgent = [] as any;
                for (let item of _data["UserAgent"])
                    this.userAgent!.push(item);
            }
            if (Array.isArray(_data["Vary"])) {
                this.vary = [] as any;
                for (let item of _data["Vary"])
                    this.vary!.push(item);
            }
            if (Array.isArray(_data["Via"])) {
                this.via = [] as any;
                for (let item of _data["Via"])
                    this.via!.push(item);
            }
            if (Array.isArray(_data["Warning"])) {
                this.warning = [] as any;
                for (let item of _data["Warning"])
                    this.warning!.push(item);
            }
            if (Array.isArray(_data["WebSocketSubProtocols"])) {
                this.webSocketSubProtocols = [] as any;
                for (let item of _data["WebSocketSubProtocols"])
                    this.webSocketSubProtocols!.push(item);
            }
            if (Array.isArray(_data["WWWAuthenticate"])) {
                this.wWWAuthenticate = [] as any;
                for (let item of _data["WWWAuthenticate"])
                    this.wWWAuthenticate!.push(item);
            }
            if (Array.isArray(_data["XContentTypeOptions"])) {
                this.xContentTypeOptions = [] as any;
                for (let item of _data["XContentTypeOptions"])
                    this.xContentTypeOptions!.push(item);
            }
            if (Array.isArray(_data["XFrameOptions"])) {
                this.xFrameOptions = [] as any;
                for (let item of _data["XFrameOptions"])
                    this.xFrameOptions!.push(item);
            }
            if (Array.isArray(_data["XPoweredBy"])) {
                this.xPoweredBy = [] as any;
                for (let item of _data["XPoweredBy"])
                    this.xPoweredBy!.push(item);
            }
            if (Array.isArray(_data["XRequestedWith"])) {
                this.xRequestedWith = [] as any;
                for (let item of _data["XRequestedWith"])
                    this.xRequestedWith!.push(item);
            }
            if (Array.isArray(_data["XUACompatible"])) {
                this.xUACompatible = [] as any;
                for (let item of _data["XUACompatible"])
                    this.xUACompatible!.push(item);
            }
            if (Array.isArray(_data["XXSSProtection"])) {
                this.xXSSProtection = [] as any;
                for (let item of _data["XXSSProtection"])
                    this.xXSSProtection!.push(item);
            }
        }
    }

    static fromJS(data: any): IHeaderDictionary {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IHeaderDictionary' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.item)) {
            data["Item"] = [];
            for (let item of this.item)
                data["Item"].push(item);
        }
        data["ContentLength"] = this.contentLength;
        if (Array.isArray(this.accept)) {
            data["Accept"] = [];
            for (let item of this.accept)
                data["Accept"].push(item);
        }
        if (Array.isArray(this.acceptCharset)) {
            data["AcceptCharset"] = [];
            for (let item of this.acceptCharset)
                data["AcceptCharset"].push(item);
        }
        if (Array.isArray(this.acceptEncoding)) {
            data["AcceptEncoding"] = [];
            for (let item of this.acceptEncoding)
                data["AcceptEncoding"].push(item);
        }
        if (Array.isArray(this.acceptLanguage)) {
            data["AcceptLanguage"] = [];
            for (let item of this.acceptLanguage)
                data["AcceptLanguage"].push(item);
        }
        if (Array.isArray(this.acceptRanges)) {
            data["AcceptRanges"] = [];
            for (let item of this.acceptRanges)
                data["AcceptRanges"].push(item);
        }
        if (Array.isArray(this.accessControlAllowCredentials)) {
            data["AccessControlAllowCredentials"] = [];
            for (let item of this.accessControlAllowCredentials)
                data["AccessControlAllowCredentials"].push(item);
        }
        if (Array.isArray(this.accessControlAllowHeaders)) {
            data["AccessControlAllowHeaders"] = [];
            for (let item of this.accessControlAllowHeaders)
                data["AccessControlAllowHeaders"].push(item);
        }
        if (Array.isArray(this.accessControlAllowMethods)) {
            data["AccessControlAllowMethods"] = [];
            for (let item of this.accessControlAllowMethods)
                data["AccessControlAllowMethods"].push(item);
        }
        if (Array.isArray(this.accessControlAllowOrigin)) {
            data["AccessControlAllowOrigin"] = [];
            for (let item of this.accessControlAllowOrigin)
                data["AccessControlAllowOrigin"].push(item);
        }
        if (Array.isArray(this.accessControlExposeHeaders)) {
            data["AccessControlExposeHeaders"] = [];
            for (let item of this.accessControlExposeHeaders)
                data["AccessControlExposeHeaders"].push(item);
        }
        if (Array.isArray(this.accessControlMaxAge)) {
            data["AccessControlMaxAge"] = [];
            for (let item of this.accessControlMaxAge)
                data["AccessControlMaxAge"].push(item);
        }
        if (Array.isArray(this.accessControlRequestHeaders)) {
            data["AccessControlRequestHeaders"] = [];
            for (let item of this.accessControlRequestHeaders)
                data["AccessControlRequestHeaders"].push(item);
        }
        if (Array.isArray(this.accessControlRequestMethod)) {
            data["AccessControlRequestMethod"] = [];
            for (let item of this.accessControlRequestMethod)
                data["AccessControlRequestMethod"].push(item);
        }
        if (Array.isArray(this.age)) {
            data["Age"] = [];
            for (let item of this.age)
                data["Age"].push(item);
        }
        if (Array.isArray(this.allow)) {
            data["Allow"] = [];
            for (let item of this.allow)
                data["Allow"].push(item);
        }
        if (Array.isArray(this.altSvc)) {
            data["AltSvc"] = [];
            for (let item of this.altSvc)
                data["AltSvc"].push(item);
        }
        if (Array.isArray(this.authorization)) {
            data["Authorization"] = [];
            for (let item of this.authorization)
                data["Authorization"].push(item);
        }
        if (Array.isArray(this.baggage)) {
            data["Baggage"] = [];
            for (let item of this.baggage)
                data["Baggage"].push(item);
        }
        if (Array.isArray(this.cacheControl)) {
            data["CacheControl"] = [];
            for (let item of this.cacheControl)
                data["CacheControl"].push(item);
        }
        if (Array.isArray(this.connection)) {
            data["Connection"] = [];
            for (let item of this.connection)
                data["Connection"].push(item);
        }
        if (Array.isArray(this.contentDisposition)) {
            data["ContentDisposition"] = [];
            for (let item of this.contentDisposition)
                data["ContentDisposition"].push(item);
        }
        if (Array.isArray(this.contentEncoding)) {
            data["ContentEncoding"] = [];
            for (let item of this.contentEncoding)
                data["ContentEncoding"].push(item);
        }
        if (Array.isArray(this.contentLanguage)) {
            data["ContentLanguage"] = [];
            for (let item of this.contentLanguage)
                data["ContentLanguage"].push(item);
        }
        if (Array.isArray(this.contentLocation)) {
            data["ContentLocation"] = [];
            for (let item of this.contentLocation)
                data["ContentLocation"].push(item);
        }
        if (Array.isArray(this.contentMD5)) {
            data["ContentMD5"] = [];
            for (let item of this.contentMD5)
                data["ContentMD5"].push(item);
        }
        if (Array.isArray(this.contentRange)) {
            data["ContentRange"] = [];
            for (let item of this.contentRange)
                data["ContentRange"].push(item);
        }
        if (Array.isArray(this.contentSecurityPolicy)) {
            data["ContentSecurityPolicy"] = [];
            for (let item of this.contentSecurityPolicy)
                data["ContentSecurityPolicy"].push(item);
        }
        if (Array.isArray(this.contentSecurityPolicyReportOnly)) {
            data["ContentSecurityPolicyReportOnly"] = [];
            for (let item of this.contentSecurityPolicyReportOnly)
                data["ContentSecurityPolicyReportOnly"].push(item);
        }
        if (Array.isArray(this.contentType)) {
            data["ContentType"] = [];
            for (let item of this.contentType)
                data["ContentType"].push(item);
        }
        if (Array.isArray(this.correlationContext)) {
            data["CorrelationContext"] = [];
            for (let item of this.correlationContext)
                data["CorrelationContext"].push(item);
        }
        if (Array.isArray(this.cookie)) {
            data["Cookie"] = [];
            for (let item of this.cookie)
                data["Cookie"].push(item);
        }
        if (Array.isArray(this.date)) {
            data["Date"] = [];
            for (let item of this.date)
                data["Date"].push(item);
        }
        if (Array.isArray(this.eTag)) {
            data["ETag"] = [];
            for (let item of this.eTag)
                data["ETag"].push(item);
        }
        if (Array.isArray(this.expires)) {
            data["Expires"] = [];
            for (let item of this.expires)
                data["Expires"].push(item);
        }
        if (Array.isArray(this.expect)) {
            data["Expect"] = [];
            for (let item of this.expect)
                data["Expect"].push(item);
        }
        if (Array.isArray(this.from)) {
            data["From"] = [];
            for (let item of this.from)
                data["From"].push(item);
        }
        if (Array.isArray(this.grpcAcceptEncoding)) {
            data["GrpcAcceptEncoding"] = [];
            for (let item of this.grpcAcceptEncoding)
                data["GrpcAcceptEncoding"].push(item);
        }
        if (Array.isArray(this.grpcEncoding)) {
            data["GrpcEncoding"] = [];
            for (let item of this.grpcEncoding)
                data["GrpcEncoding"].push(item);
        }
        if (Array.isArray(this.grpcMessage)) {
            data["GrpcMessage"] = [];
            for (let item of this.grpcMessage)
                data["GrpcMessage"].push(item);
        }
        if (Array.isArray(this.grpcStatus)) {
            data["GrpcStatus"] = [];
            for (let item of this.grpcStatus)
                data["GrpcStatus"].push(item);
        }
        if (Array.isArray(this.grpcTimeout)) {
            data["GrpcTimeout"] = [];
            for (let item of this.grpcTimeout)
                data["GrpcTimeout"].push(item);
        }
        if (Array.isArray(this.host)) {
            data["Host"] = [];
            for (let item of this.host)
                data["Host"].push(item);
        }
        if (Array.isArray(this.keepAlive)) {
            data["KeepAlive"] = [];
            for (let item of this.keepAlive)
                data["KeepAlive"].push(item);
        }
        if (Array.isArray(this.ifMatch)) {
            data["IfMatch"] = [];
            for (let item of this.ifMatch)
                data["IfMatch"].push(item);
        }
        if (Array.isArray(this.ifModifiedSince)) {
            data["IfModifiedSince"] = [];
            for (let item of this.ifModifiedSince)
                data["IfModifiedSince"].push(item);
        }
        if (Array.isArray(this.ifNoneMatch)) {
            data["IfNoneMatch"] = [];
            for (let item of this.ifNoneMatch)
                data["IfNoneMatch"].push(item);
        }
        if (Array.isArray(this.ifRange)) {
            data["IfRange"] = [];
            for (let item of this.ifRange)
                data["IfRange"].push(item);
        }
        if (Array.isArray(this.ifUnmodifiedSince)) {
            data["IfUnmodifiedSince"] = [];
            for (let item of this.ifUnmodifiedSince)
                data["IfUnmodifiedSince"].push(item);
        }
        if (Array.isArray(this.lastModified)) {
            data["LastModified"] = [];
            for (let item of this.lastModified)
                data["LastModified"].push(item);
        }
        if (Array.isArray(this.link)) {
            data["Link"] = [];
            for (let item of this.link)
                data["Link"].push(item);
        }
        if (Array.isArray(this.location)) {
            data["Location"] = [];
            for (let item of this.location)
                data["Location"].push(item);
        }
        if (Array.isArray(this.maxForwards)) {
            data["MaxForwards"] = [];
            for (let item of this.maxForwards)
                data["MaxForwards"].push(item);
        }
        if (Array.isArray(this.origin)) {
            data["Origin"] = [];
            for (let item of this.origin)
                data["Origin"].push(item);
        }
        if (Array.isArray(this.pragma)) {
            data["Pragma"] = [];
            for (let item of this.pragma)
                data["Pragma"].push(item);
        }
        if (Array.isArray(this.proxyAuthenticate)) {
            data["ProxyAuthenticate"] = [];
            for (let item of this.proxyAuthenticate)
                data["ProxyAuthenticate"].push(item);
        }
        if (Array.isArray(this.proxyAuthorization)) {
            data["ProxyAuthorization"] = [];
            for (let item of this.proxyAuthorization)
                data["ProxyAuthorization"].push(item);
        }
        if (Array.isArray(this.proxyConnection)) {
            data["ProxyConnection"] = [];
            for (let item of this.proxyConnection)
                data["ProxyConnection"].push(item);
        }
        if (Array.isArray(this.range)) {
            data["Range"] = [];
            for (let item of this.range)
                data["Range"].push(item);
        }
        if (Array.isArray(this.referer)) {
            data["Referer"] = [];
            for (let item of this.referer)
                data["Referer"].push(item);
        }
        if (Array.isArray(this.retryAfter)) {
            data["RetryAfter"] = [];
            for (let item of this.retryAfter)
                data["RetryAfter"].push(item);
        }
        if (Array.isArray(this.requestId)) {
            data["RequestId"] = [];
            for (let item of this.requestId)
                data["RequestId"].push(item);
        }
        if (Array.isArray(this.secWebSocketAccept)) {
            data["SecWebSocketAccept"] = [];
            for (let item of this.secWebSocketAccept)
                data["SecWebSocketAccept"].push(item);
        }
        if (Array.isArray(this.secWebSocketKey)) {
            data["SecWebSocketKey"] = [];
            for (let item of this.secWebSocketKey)
                data["SecWebSocketKey"].push(item);
        }
        if (Array.isArray(this.secWebSocketProtocol)) {
            data["SecWebSocketProtocol"] = [];
            for (let item of this.secWebSocketProtocol)
                data["SecWebSocketProtocol"].push(item);
        }
        if (Array.isArray(this.secWebSocketVersion)) {
            data["SecWebSocketVersion"] = [];
            for (let item of this.secWebSocketVersion)
                data["SecWebSocketVersion"].push(item);
        }
        if (Array.isArray(this.secWebSocketExtensions)) {
            data["SecWebSocketExtensions"] = [];
            for (let item of this.secWebSocketExtensions)
                data["SecWebSocketExtensions"].push(item);
        }
        if (Array.isArray(this.server)) {
            data["Server"] = [];
            for (let item of this.server)
                data["Server"].push(item);
        }
        if (Array.isArray(this.setCookie)) {
            data["SetCookie"] = [];
            for (let item of this.setCookie)
                data["SetCookie"].push(item);
        }
        if (Array.isArray(this.strictTransportSecurity)) {
            data["StrictTransportSecurity"] = [];
            for (let item of this.strictTransportSecurity)
                data["StrictTransportSecurity"].push(item);
        }
        if (Array.isArray(this.tE)) {
            data["TE"] = [];
            for (let item of this.tE)
                data["TE"].push(item);
        }
        if (Array.isArray(this.trailer)) {
            data["Trailer"] = [];
            for (let item of this.trailer)
                data["Trailer"].push(item);
        }
        if (Array.isArray(this.transferEncoding)) {
            data["TransferEncoding"] = [];
            for (let item of this.transferEncoding)
                data["TransferEncoding"].push(item);
        }
        if (Array.isArray(this.translate)) {
            data["Translate"] = [];
            for (let item of this.translate)
                data["Translate"].push(item);
        }
        if (Array.isArray(this.traceParent)) {
            data["TraceParent"] = [];
            for (let item of this.traceParent)
                data["TraceParent"].push(item);
        }
        if (Array.isArray(this.traceState)) {
            data["TraceState"] = [];
            for (let item of this.traceState)
                data["TraceState"].push(item);
        }
        if (Array.isArray(this.upgrade)) {
            data["Upgrade"] = [];
            for (let item of this.upgrade)
                data["Upgrade"].push(item);
        }
        if (Array.isArray(this.upgradeInsecureRequests)) {
            data["UpgradeInsecureRequests"] = [];
            for (let item of this.upgradeInsecureRequests)
                data["UpgradeInsecureRequests"].push(item);
        }
        if (Array.isArray(this.userAgent)) {
            data["UserAgent"] = [];
            for (let item of this.userAgent)
                data["UserAgent"].push(item);
        }
        if (Array.isArray(this.vary)) {
            data["Vary"] = [];
            for (let item of this.vary)
                data["Vary"].push(item);
        }
        if (Array.isArray(this.via)) {
            data["Via"] = [];
            for (let item of this.via)
                data["Via"].push(item);
        }
        if (Array.isArray(this.warning)) {
            data["Warning"] = [];
            for (let item of this.warning)
                data["Warning"].push(item);
        }
        if (Array.isArray(this.webSocketSubProtocols)) {
            data["WebSocketSubProtocols"] = [];
            for (let item of this.webSocketSubProtocols)
                data["WebSocketSubProtocols"].push(item);
        }
        if (Array.isArray(this.wWWAuthenticate)) {
            data["WWWAuthenticate"] = [];
            for (let item of this.wWWAuthenticate)
                data["WWWAuthenticate"].push(item);
        }
        if (Array.isArray(this.xContentTypeOptions)) {
            data["XContentTypeOptions"] = [];
            for (let item of this.xContentTypeOptions)
                data["XContentTypeOptions"].push(item);
        }
        if (Array.isArray(this.xFrameOptions)) {
            data["XFrameOptions"] = [];
            for (let item of this.xFrameOptions)
                data["XFrameOptions"].push(item);
        }
        if (Array.isArray(this.xPoweredBy)) {
            data["XPoweredBy"] = [];
            for (let item of this.xPoweredBy)
                data["XPoweredBy"].push(item);
        }
        if (Array.isArray(this.xRequestedWith)) {
            data["XRequestedWith"] = [];
            for (let item of this.xRequestedWith)
                data["XRequestedWith"].push(item);
        }
        if (Array.isArray(this.xUACompatible)) {
            data["XUACompatible"] = [];
            for (let item of this.xUACompatible)
                data["XUACompatible"].push(item);
        }
        if (Array.isArray(this.xXSSProtection)) {
            data["XXSSProtection"] = [];
            for (let item of this.xXSSProtection)
                data["XXSSProtection"].push(item);
        }
        return data;
    }
}

export interface IIHeaderDictionary {
    item?: any[];
    contentLength?: number | undefined;
    accept?: any[];
    acceptCharset?: any[];
    acceptEncoding?: any[];
    acceptLanguage?: any[];
    acceptRanges?: any[];
    accessControlAllowCredentials?: any[];
    accessControlAllowHeaders?: any[];
    accessControlAllowMethods?: any[];
    accessControlAllowOrigin?: any[];
    accessControlExposeHeaders?: any[];
    accessControlMaxAge?: any[];
    accessControlRequestHeaders?: any[];
    accessControlRequestMethod?: any[];
    age?: any[];
    allow?: any[];
    altSvc?: any[];
    authorization?: any[];
    baggage?: any[];
    cacheControl?: any[];
    connection?: any[];
    contentDisposition?: any[];
    contentEncoding?: any[];
    contentLanguage?: any[];
    contentLocation?: any[];
    contentMD5?: any[];
    contentRange?: any[];
    contentSecurityPolicy?: any[];
    contentSecurityPolicyReportOnly?: any[];
    contentType?: any[];
    correlationContext?: any[];
    cookie?: any[];
    date?: any[];
    eTag?: any[];
    expires?: any[];
    expect?: any[];
    from?: any[];
    grpcAcceptEncoding?: any[];
    grpcEncoding?: any[];
    grpcMessage?: any[];
    grpcStatus?: any[];
    grpcTimeout?: any[];
    host?: any[];
    keepAlive?: any[];
    ifMatch?: any[];
    ifModifiedSince?: any[];
    ifNoneMatch?: any[];
    ifRange?: any[];
    ifUnmodifiedSince?: any[];
    lastModified?: any[];
    link?: any[];
    location?: any[];
    maxForwards?: any[];
    origin?: any[];
    pragma?: any[];
    proxyAuthenticate?: any[];
    proxyAuthorization?: any[];
    proxyConnection?: any[];
    range?: any[];
    referer?: any[];
    retryAfter?: any[];
    requestId?: any[];
    secWebSocketAccept?: any[];
    secWebSocketKey?: any[];
    secWebSocketProtocol?: any[];
    secWebSocketVersion?: any[];
    secWebSocketExtensions?: any[];
    server?: any[];
    setCookie?: any[];
    strictTransportSecurity?: any[];
    tE?: any[];
    trailer?: any[];
    transferEncoding?: any[];
    translate?: any[];
    traceParent?: any[];
    traceState?: any[];
    upgrade?: any[];
    upgradeInsecureRequests?: any[];
    userAgent?: any[];
    vary?: any[];
    via?: any[];
    warning?: any[];
    webSocketSubProtocols?: any[];
    wWWAuthenticate?: any[];
    xContentTypeOptions?: any[];
    xFrameOptions?: any[];
    xPoweredBy?: any[];
    xRequestedWith?: any[];
    xUACompatible?: any[];
    xXSSProtection?: any[];
}

export class ResponseOfListOfAuthorViewModel implements IResponseOfListOfAuthorViewModel {
    data?: AuthorViewModel[];

    constructor(data?: IResponseOfListOfAuthorViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AuthorViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseOfListOfAuthorViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfListOfAuthorViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseOfListOfAuthorViewModel {
    data?: AuthorViewModel[];
}

export class PagedResponseOfListOfAuthorViewModel extends ResponseOfListOfAuthorViewModel implements IPagedResponseOfListOfAuthorViewModel {
    totalRecords?: number;

    constructor(data?: IPagedResponseOfListOfAuthorViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): PagedResponseOfListOfAuthorViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfListOfAuthorViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRecords"] = this.totalRecords;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResponseOfListOfAuthorViewModel extends IResponseOfListOfAuthorViewModel {
    totalRecords?: number;
}

export class AuthorViewModel implements IAuthorViewModel {
    id?: number;
    authorFirstName?: string | undefined;
    authorLastName?: string | undefined;
    profilePictureName?: string | undefined;
    birthday?: Date;
    country?: string | undefined;
    language?: string | undefined;
    bio?: string | undefined;
    age?: number;

    constructor(data?: IAuthorViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.authorFirstName = _data["authorFirstName"];
            this.authorLastName = _data["authorLastName"];
            this.profilePictureName = _data["profilePictureName"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.country = _data["country"];
            this.language = _data["language"];
            this.bio = _data["bio"];
            this.age = _data["age"];
        }
    }

    static fromJS(data: any): AuthorViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["authorFirstName"] = this.authorFirstName;
        data["authorLastName"] = this.authorLastName;
        data["profilePictureName"] = this.profilePictureName;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["country"] = this.country;
        data["language"] = this.language;
        data["bio"] = this.bio;
        data["age"] = this.age;
        return data;
    }
}

export interface IAuthorViewModel {
    id?: number;
    authorFirstName?: string | undefined;
    authorLastName?: string | undefined;
    profilePictureName?: string | undefined;
    birthday?: Date;
    country?: string | undefined;
    language?: string | undefined;
    bio?: string | undefined;
    age?: number;
}

export class AuthorGetListFilterViewModel implements IAuthorGetListFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    authorId?: number | undefined;
    authorFirstName?: string | undefined;
    authorLastName?: string | undefined;
    birthday?: Date | undefined;
    country?: string | undefined;
    language?: string | undefined;
    age?: number | undefined;

    constructor(data?: IAuthorGetListFilterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.authorId = _data["authorId"];
            this.authorFirstName = _data["authorFirstName"];
            this.authorLastName = _data["authorLastName"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.country = _data["country"];
            this.language = _data["language"];
            this.age = _data["age"];
        }
    }

    static fromJS(data: any): AuthorGetListFilterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorGetListFilterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["authorId"] = this.authorId;
        data["authorFirstName"] = this.authorFirstName;
        data["authorLastName"] = this.authorLastName;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["country"] = this.country;
        data["language"] = this.language;
        data["age"] = this.age;
        return data;
    }
}

export interface IAuthorGetListFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    authorId?: number | undefined;
    authorFirstName?: string | undefined;
    authorLastName?: string | undefined;
    birthday?: Date | undefined;
    country?: string | undefined;
    language?: string | undefined;
    age?: number | undefined;
}

export class AuthorProfileViewModel implements IAuthorProfileViewModel {
    id?: number;
    authorFirstName?: string | undefined;
    authorLastName?: string | undefined;
    profilePictureName?: string | undefined;
    birthday?: Date;
    country?: string | undefined;
    language?: string | undefined;
    bio?: string | undefined;
    age?: number;
    averageRate?: number;
    likes?: number;
    disLikes?: number;

    constructor(data?: IAuthorProfileViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.authorFirstName = _data["authorFirstName"];
            this.authorLastName = _data["authorLastName"];
            this.profilePictureName = _data["profilePictureName"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.country = _data["country"];
            this.language = _data["language"];
            this.bio = _data["bio"];
            this.age = _data["age"];
            this.averageRate = _data["averageRate"];
            this.likes = _data["likes"];
            this.disLikes = _data["disLikes"];
        }
    }

    static fromJS(data: any): AuthorProfileViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorProfileViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["authorFirstName"] = this.authorFirstName;
        data["authorLastName"] = this.authorLastName;
        data["profilePictureName"] = this.profilePictureName;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["country"] = this.country;
        data["language"] = this.language;
        data["bio"] = this.bio;
        data["age"] = this.age;
        data["averageRate"] = this.averageRate;
        data["likes"] = this.likes;
        data["disLikes"] = this.disLikes;
        return data;
    }
}

export interface IAuthorProfileViewModel {
    id?: number;
    authorFirstName?: string | undefined;
    authorLastName?: string | undefined;
    profilePictureName?: string | undefined;
    birthday?: Date;
    country?: string | undefined;
    language?: string | undefined;
    bio?: string | undefined;
    age?: number;
    averageRate?: number;
    likes?: number;
    disLikes?: number;
}

export class AuthorScore implements IAuthorScore {
    averageRate?: number;
    disLikes?: number;
    likes?: number;

    constructor(data?: IAuthorScore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.averageRate = _data["averageRate"];
            this.disLikes = _data["disLikes"];
            this.likes = _data["likes"];
        }
    }

    static fromJS(data: any): AuthorScore {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorScore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["averageRate"] = this.averageRate;
        data["disLikes"] = this.disLikes;
        data["likes"] = this.likes;
        return data;
    }
}

export interface IAuthorScore {
    averageRate?: number;
    disLikes?: number;
    likes?: number;
}

export class Book implements IBook {
    id?: number;
    parentId?: number | undefined;
    bookName?: string | undefined;
    publisher?: string | undefined;
    yearOfPublication?: Date;
    bookFormat?: number;
    bookType?: number;
    numberOfPages?: number;
    language?: string | undefined;
    isbn?: number;
    electronicVersionPrice?: number;
    bookPictureName?: string | undefined;
    bookPictureId?: number | undefined;
    isActive?: boolean;
    isDeleted?: boolean;
    isModified?: boolean;
    modifierId?: number | undefined;
    lastModified?: Date | undefined;
    createOn?: Date | undefined;

    constructor(data?: IBook) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.bookName = _data["bookName"];
            this.publisher = _data["publisher"];
            this.yearOfPublication = _data["yearOfPublication"] ? new Date(_data["yearOfPublication"].toString()) : <any>undefined;
            this.bookFormat = _data["bookFormat"];
            this.bookType = _data["bookType"];
            this.numberOfPages = _data["numberOfPages"];
            this.language = _data["language"];
            this.isbn = _data["isbn"];
            this.electronicVersionPrice = _data["electronicVersionPrice"];
            this.bookPictureName = _data["bookPictureName"];
            this.bookPictureId = _data["bookPictureId"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isModified = _data["isModified"];
            this.modifierId = _data["modifierId"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.createOn = _data["createOn"] ? new Date(_data["createOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Book {
        data = typeof data === 'object' ? data : {};
        let result = new Book();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["bookName"] = this.bookName;
        data["publisher"] = this.publisher;
        data["yearOfPublication"] = this.yearOfPublication ? this.yearOfPublication.toISOString() : <any>undefined;
        data["bookFormat"] = this.bookFormat;
        data["bookType"] = this.bookType;
        data["numberOfPages"] = this.numberOfPages;
        data["language"] = this.language;
        data["isbn"] = this.isbn;
        data["electronicVersionPrice"] = this.electronicVersionPrice;
        data["bookPictureName"] = this.bookPictureName;
        data["bookPictureId"] = this.bookPictureId;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isModified"] = this.isModified;
        data["modifierId"] = this.modifierId;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["createOn"] = this.createOn ? this.createOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBook {
    id?: number;
    parentId?: number | undefined;
    bookName?: string | undefined;
    publisher?: string | undefined;
    yearOfPublication?: Date;
    bookFormat?: number;
    bookType?: number;
    numberOfPages?: number;
    language?: string | undefined;
    isbn?: number;
    electronicVersionPrice?: number;
    bookPictureName?: string | undefined;
    bookPictureId?: number | undefined;
    isActive?: boolean;
    isDeleted?: boolean;
    isModified?: boolean;
    modifierId?: number | undefined;
    lastModified?: Date | undefined;
    createOn?: Date | undefined;
}

export class Subjects implements ISubjects {
    id?: number;
    title?: string;

    constructor(data?: ISubjects) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): Subjects {
        data = typeof data === 'object' ? data : {};
        let result = new Subjects();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface ISubjects {
    id?: number;
    title?: string;
}

export class Category implements ICategory {
    id?: number;
    parentId?: number;
    title?: string | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["title"] = this.title;
        return data;
    }
}

export interface ICategory {
    id?: number;
    parentId?: number;
    title?: string | undefined;
}

export class Like implements ILike {
    id?: number;
    userId?: number;
    entityType?: number;
    entityId?: number;
    createOn?: Date;
    type?: number;

    constructor(data?: ILike) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.createOn = _data["createOn"] ? new Date(_data["createOn"].toString()) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Like {
        data = typeof data === 'object' ? data : {};
        let result = new Like();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["createOn"] = this.createOn ? this.createOn.toISOString() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

export interface ILike {
    id?: number;
    userId?: number;
    entityType?: number;
    entityId?: number;
    createOn?: Date;
    type?: number;
}

export class GetLikeSendViewModel implements IGetLikeSendViewModel {
    entityType?: number | undefined;
    entityId?: number | undefined;

    constructor(data?: IGetLikeSendViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
        }
    }

    static fromJS(data: any): GetLikeSendViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new GetLikeSendViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        return data;
    }
}

export interface IGetLikeSendViewModel {
    entityType?: number | undefined;
    entityId?: number | undefined;
}

export class ChangeLikeViewModel implements IChangeLikeViewModel {
    entityType?: number;
    entityId?: number;
    type?: number;

    constructor(data?: IChangeLikeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ChangeLikeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeLikeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["type"] = this.type;
        return data;
    }
}

export interface IChangeLikeViewModel {
    entityType?: number;
    entityId?: number;
    type?: number;
}

export class Rate implements IRate {
    id?: number;
    userId?: number;
    entityType?: number;
    entityId?: number;
    rateValue?: number;
    createOn?: Date;

    constructor(data?: IRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.rateValue = _data["rateValue"];
            this.createOn = _data["createOn"] ? new Date(_data["createOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Rate {
        data = typeof data === 'object' ? data : {};
        let result = new Rate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["rateValue"] = this.rateValue;
        data["createOn"] = this.createOn ? this.createOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRate {
    id?: number;
    userId?: number;
    entityType?: number;
    entityId?: number;
    rateValue?: number;
    createOn?: Date;
}

export class GetRateSendViewModel implements IGetRateSendViewModel {
    entityType?: number | undefined;
    entityId?: number | undefined;

    constructor(data?: IGetRateSendViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
        }
    }

    static fromJS(data: any): GetRateSendViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new GetRateSendViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        return data;
    }
}

export interface IGetRateSendViewModel {
    entityType?: number | undefined;
    entityId?: number | undefined;
}

export class RateViewModel implements IRateViewModel {
    entityType?: number;
    entityId?: number;
    rateValue?: number;

    constructor(data?: IRateViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.rateValue = _data["rateValue"];
        }
    }

    static fromJS(data: any): RateViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RateViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["rateValue"] = this.rateValue;
        return data;
    }
}

export interface IRateViewModel {
    entityType?: number;
    entityId?: number;
    rateValue?: number;
}

export class Review implements IReview {
    id?: number;
    parentId?: number;
    userId?: number;
    entityType?: number;
    entityId?: number;
    commentValue?: string | undefined;
    commentDate?: Date;

    constructor(data?: IReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.userId = _data["userId"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.commentValue = _data["commentValue"];
            this.commentDate = _data["commentDate"] ? new Date(_data["commentDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Review {
        data = typeof data === 'object' ? data : {};
        let result = new Review();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["userId"] = this.userId;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["commentValue"] = this.commentValue;
        data["commentDate"] = this.commentDate ? this.commentDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IReview {
    id?: number;
    parentId?: number;
    userId?: number;
    entityType?: number;
    entityId?: number;
    commentValue?: string | undefined;
    commentDate?: Date;
}

export class ReviewAddViewModel implements IReviewAddViewModel {
    parentId?: number;
    entityType?: number;
    entityId?: number;
    commentValue?: string | undefined;

    constructor(data?: IReviewAddViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.commentValue = _data["commentValue"];
        }
    }

    static fromJS(data: any): ReviewAddViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewAddViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["commentValue"] = this.commentValue;
        return data;
    }
}

export interface IReviewAddViewModel {
    parentId?: number;
    entityType?: number;
    entityId?: number;
    commentValue?: string | undefined;
}

export class ReviewUpdateViewModel implements IReviewUpdateViewModel {
    id?: number;
    entityId?: number;
    commentValue?: string | undefined;

    constructor(data?: IReviewUpdateViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityId = _data["entityId"];
            this.commentValue = _data["commentValue"];
        }
    }

    static fromJS(data: any): ReviewUpdateViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewUpdateViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityId"] = this.entityId;
        data["commentValue"] = this.commentValue;
        return data;
    }
}

export interface IReviewUpdateViewModel {
    id?: number;
    entityId?: number;
    commentValue?: string | undefined;
}

export class ResponseOfListOfTranslatorGetListViewModel implements IResponseOfListOfTranslatorGetListViewModel {
    data?: TranslatorGetListViewModel[];

    constructor(data?: IResponseOfListOfTranslatorGetListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TranslatorGetListViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseOfListOfTranslatorGetListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfListOfTranslatorGetListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseOfListOfTranslatorGetListViewModel {
    data?: TranslatorGetListViewModel[];
}

export class PagedResponseOfListOfTranslatorGetListViewModel extends ResponseOfListOfTranslatorGetListViewModel implements IPagedResponseOfListOfTranslatorGetListViewModel {
    totalRecords?: number;

    constructor(data?: IPagedResponseOfListOfTranslatorGetListViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): PagedResponseOfListOfTranslatorGetListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfListOfTranslatorGetListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRecords"] = this.totalRecords;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResponseOfListOfTranslatorGetListViewModel extends IResponseOfListOfTranslatorGetListViewModel {
    totalRecords?: number;
}

export class TranslatorGetListViewModel implements ITranslatorGetListViewModel {
    id?: number;
    translatorFirstName?: string | undefined;
    translatorLastName?: string | undefined;
    birthday?: Date;
    country?: string | undefined;
    language?: string | undefined;
    age?: number;
    bio?: string | undefined;
    profilePictureName?: string | undefined;

    constructor(data?: ITranslatorGetListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.translatorFirstName = _data["translatorFirstName"];
            this.translatorLastName = _data["translatorLastName"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.country = _data["country"];
            this.language = _data["language"];
            this.age = _data["age"];
            this.bio = _data["bio"];
            this.profilePictureName = _data["profilePictureName"];
        }
    }

    static fromJS(data: any): TranslatorGetListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TranslatorGetListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["translatorFirstName"] = this.translatorFirstName;
        data["translatorLastName"] = this.translatorLastName;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["country"] = this.country;
        data["language"] = this.language;
        data["age"] = this.age;
        data["bio"] = this.bio;
        data["profilePictureName"] = this.profilePictureName;
        return data;
    }
}

export interface ITranslatorGetListViewModel {
    id?: number;
    translatorFirstName?: string | undefined;
    translatorLastName?: string | undefined;
    birthday?: Date;
    country?: string | undefined;
    language?: string | undefined;
    age?: number;
    bio?: string | undefined;
    profilePictureName?: string | undefined;
}

export class TranslatorGetListFilterViewModel implements ITranslatorGetListFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    translatorId?: number | undefined;
    translatorFirstName?: string | undefined;
    translatorLastName?: string | undefined;
    birthday?: Date | undefined;
    country?: string | undefined;
    language?: string | undefined;
    age?: number | undefined;

    constructor(data?: ITranslatorGetListFilterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.translatorId = _data["translatorId"];
            this.translatorFirstName = _data["translatorFirstName"];
            this.translatorLastName = _data["translatorLastName"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.country = _data["country"];
            this.language = _data["language"];
            this.age = _data["age"];
        }
    }

    static fromJS(data: any): TranslatorGetListFilterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TranslatorGetListFilterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["translatorId"] = this.translatorId;
        data["translatorFirstName"] = this.translatorFirstName;
        data["translatorLastName"] = this.translatorLastName;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["country"] = this.country;
        data["language"] = this.language;
        data["age"] = this.age;
        return data;
    }
}

export interface ITranslatorGetListFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    translatorId?: number | undefined;
    translatorFirstName?: string | undefined;
    translatorLastName?: string | undefined;
    birthday?: Date | undefined;
    country?: string | undefined;
    language?: string | undefined;
    age?: number | undefined;
}

export class Translator implements ITranslator {
    id?: number;
    translatorFirstName?: string | undefined;
    translatorLastName?: string | undefined;
    birthday?: Date;
    country?: string | undefined;
    language?: string | undefined;
    age?: number;
    bio?: string | undefined;
    profilePictureId?: number | undefined;
    profilePictureName?: string | undefined;

    constructor(data?: ITranslator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.translatorFirstName = _data["translatorFirstName"];
            this.translatorLastName = _data["translatorLastName"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.country = _data["country"];
            this.language = _data["language"];
            this.age = _data["age"];
            this.bio = _data["bio"];
            this.profilePictureId = _data["profilePictureId"];
            this.profilePictureName = _data["profilePictureName"];
        }
    }

    static fromJS(data: any): Translator {
        data = typeof data === 'object' ? data : {};
        let result = new Translator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["translatorFirstName"] = this.translatorFirstName;
        data["translatorLastName"] = this.translatorLastName;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["country"] = this.country;
        data["language"] = this.language;
        data["age"] = this.age;
        data["bio"] = this.bio;
        data["profilePictureId"] = this.profilePictureId;
        data["profilePictureName"] = this.profilePictureName;
        return data;
    }
}

export interface ITranslator {
    id?: number;
    translatorFirstName?: string | undefined;
    translatorLastName?: string | undefined;
    birthday?: Date;
    country?: string | undefined;
    language?: string | undefined;
    age?: number;
    bio?: string | undefined;
    profilePictureId?: number | undefined;
    profilePictureName?: string | undefined;
}

export class UserBook implements IUserBook {
    id?: number;
    userId?: number;
    bookId?: number;
    isMarked?: boolean;
    isAdded?: boolean;
    isPurchase?: boolean;
    createOn?: Date;

    constructor(data?: IUserBook) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.bookId = _data["bookId"];
            this.isMarked = _data["isMarked"];
            this.isAdded = _data["isAdded"];
            this.isPurchase = _data["isPurchase"];
            this.createOn = _data["createOn"] ? new Date(_data["createOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserBook {
        data = typeof data === 'object' ? data : {};
        let result = new UserBook();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["bookId"] = this.bookId;
        data["isMarked"] = this.isMarked;
        data["isAdded"] = this.isAdded;
        data["isPurchase"] = this.isPurchase;
        data["createOn"] = this.createOn ? this.createOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserBook {
    id?: number;
    userId?: number;
    bookId?: number;
    isMarked?: boolean;
    isAdded?: boolean;
    isPurchase?: boolean;
    createOn?: Date;
}

export class ResponseOfListOfGetDepositResultViewModel implements IResponseOfListOfGetDepositResultViewModel {
    data?: GetDepositResultViewModel[];

    constructor(data?: IResponseOfListOfGetDepositResultViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetDepositResultViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseOfListOfGetDepositResultViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfListOfGetDepositResultViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseOfListOfGetDepositResultViewModel {
    data?: GetDepositResultViewModel[];
}

export class PagedResponseOfListOfGetDepositResultViewModel extends ResponseOfListOfGetDepositResultViewModel implements IPagedResponseOfListOfGetDepositResultViewModel {
    totalRecords?: number;

    constructor(data?: IPagedResponseOfListOfGetDepositResultViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): PagedResponseOfListOfGetDepositResultViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfListOfGetDepositResultViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRecords"] = this.totalRecords;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResponseOfListOfGetDepositResultViewModel extends IResponseOfListOfGetDepositResultViewModel {
    totalRecords?: number;
}

export class GetDepositResultViewModel implements IGetDepositResultViewModel {
    transactionId?: number;
    operationType?: number;
    statusType?: number;
    amount?: number;
    userId?: number;
    userName?: string | undefined;
    trCode?: number;
    paymentMethod?: number | undefined;
    verifyDate?: Date | undefined;
    comment?: string | undefined;
    creatorId?: number | undefined;
    creatorUserName?: string | undefined;
    createOn?: Date;

    constructor(data?: IGetDepositResultViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.operationType = _data["operationType"];
            this.statusType = _data["statusType"];
            this.amount = _data["amount"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.trCode = _data["trCode"];
            this.paymentMethod = _data["paymentMethod"];
            this.verifyDate = _data["verifyDate"] ? new Date(_data["verifyDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.creatorId = _data["creatorId"];
            this.creatorUserName = _data["creatorUserName"];
            this.createOn = _data["createOn"] ? new Date(_data["createOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDepositResultViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new GetDepositResultViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["operationType"] = this.operationType;
        data["statusType"] = this.statusType;
        data["amount"] = this.amount;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["trCode"] = this.trCode;
        data["paymentMethod"] = this.paymentMethod;
        data["verifyDate"] = this.verifyDate ? this.verifyDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["creatorId"] = this.creatorId;
        data["creatorUserName"] = this.creatorUserName;
        data["createOn"] = this.createOn ? this.createOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetDepositResultViewModel {
    transactionId?: number;
    operationType?: number;
    statusType?: number;
    amount?: number;
    userId?: number;
    userName?: string | undefined;
    trCode?: number;
    paymentMethod?: number | undefined;
    verifyDate?: Date | undefined;
    comment?: string | undefined;
    creatorId?: number | undefined;
    creatorUserName?: string | undefined;
    createOn?: Date;
}

export class TransactionFilterViewModel implements ITransactionFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    operationType?: number;
    statusType?: number;
    amount?: number;
    userId?: number;
    userName?: string | undefined;
    paymentMethod?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;

    constructor(data?: ITransactionFilterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.operationType = _data["operationType"];
            this.statusType = _data["statusType"];
            this.amount = _data["amount"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.paymentMethod = _data["paymentMethod"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TransactionFilterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionFilterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["operationType"] = this.operationType;
        data["statusType"] = this.statusType;
        data["amount"] = this.amount;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["paymentMethod"] = this.paymentMethod;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITransactionFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    operationType?: number;
    statusType?: number;
    amount?: number;
    userId?: number;
    userName?: string | undefined;
    paymentMethod?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
}

export class DepositRequest implements IDepositRequest {
    id?: number;
    userId?: number;
    amount?: number;
    depositType?: number;
    traceNumber?: number;
    accountIdentity?: string | undefined;
    statusType?: number;
    verifyDate?: Date;
    createOn?: Date;

    constructor(data?: IDepositRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.amount = _data["amount"];
            this.depositType = _data["depositType"];
            this.traceNumber = _data["traceNumber"];
            this.accountIdentity = _data["accountIdentity"];
            this.statusType = _data["statusType"];
            this.verifyDate = _data["verifyDate"] ? new Date(_data["verifyDate"].toString()) : <any>undefined;
            this.createOn = _data["createOn"] ? new Date(_data["createOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DepositRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DepositRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["amount"] = this.amount;
        data["depositType"] = this.depositType;
        data["traceNumber"] = this.traceNumber;
        data["accountIdentity"] = this.accountIdentity;
        data["statusType"] = this.statusType;
        data["verifyDate"] = this.verifyDate ? this.verifyDate.toISOString() : <any>undefined;
        data["createOn"] = this.createOn ? this.createOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDepositRequest {
    id?: number;
    userId?: number;
    amount?: number;
    depositType?: number;
    traceNumber?: number;
    accountIdentity?: string | undefined;
    statusType?: number;
    verifyDate?: Date;
    createOn?: Date;
}

export class ResponseOfListOfGetTransactionReportViewModel implements IResponseOfListOfGetTransactionReportViewModel {
    data?: GetTransactionReportViewModel[];

    constructor(data?: IResponseOfListOfGetTransactionReportViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetTransactionReportViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseOfListOfGetTransactionReportViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfListOfGetTransactionReportViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseOfListOfGetTransactionReportViewModel {
    data?: GetTransactionReportViewModel[];
}

export class PagedResponseOfListOfGetTransactionReportViewModel extends ResponseOfListOfGetTransactionReportViewModel implements IPagedResponseOfListOfGetTransactionReportViewModel {
    totalRecords?: number;

    constructor(data?: IPagedResponseOfListOfGetTransactionReportViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): PagedResponseOfListOfGetTransactionReportViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfListOfGetTransactionReportViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRecords"] = this.totalRecords;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResponseOfListOfGetTransactionReportViewModel extends IResponseOfListOfGetTransactionReportViewModel {
    totalRecords?: number;
}

export class GetTransactionReportViewModel implements IGetTransactionReportViewModel {
    id?: number;
    operationType?: number;
    operationTitle?: string | undefined;
    statusType?: number;
    statusTitle?: string | undefined;
    amount?: number;
    trCode?: number;
    comment?: string | undefined;
    docType?: number;
    trDate?: Date;

    constructor(data?: IGetTransactionReportViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationType = _data["operationType"];
            this.operationTitle = _data["operationTitle"];
            this.statusType = _data["statusType"];
            this.statusTitle = _data["statusTitle"];
            this.amount = _data["amount"];
            this.trCode = _data["trCode"];
            this.comment = _data["comment"];
            this.docType = _data["docType"];
            this.trDate = _data["trDate"] ? new Date(_data["trDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTransactionReportViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransactionReportViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationType"] = this.operationType;
        data["operationTitle"] = this.operationTitle;
        data["statusType"] = this.statusType;
        data["statusTitle"] = this.statusTitle;
        data["amount"] = this.amount;
        data["trCode"] = this.trCode;
        data["comment"] = this.comment;
        data["docType"] = this.docType;
        data["trDate"] = this.trDate ? this.trDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetTransactionReportViewModel {
    id?: number;
    operationType?: number;
    operationTitle?: string | undefined;
    statusType?: number;
    statusTitle?: string | undefined;
    amount?: number;
    trCode?: number;
    comment?: string | undefined;
    docType?: number;
    trDate?: Date;
}

export class GetTransactionReportFilterViewModel implements IGetTransactionReportFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;

    constructor(data?: IGetTransactionReportFilterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTransactionReportFilterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransactionReportFilterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetTransactionReportFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
}

export class ResponseOfListOfTransactionInfoViewModel implements IResponseOfListOfTransactionInfoViewModel {
    data?: TransactionInfoViewModel[];

    constructor(data?: IResponseOfListOfTransactionInfoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TransactionInfoViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseOfListOfTransactionInfoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfListOfTransactionInfoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseOfListOfTransactionInfoViewModel {
    data?: TransactionInfoViewModel[];
}

export class PagedResponseOfListOfTransactionInfoViewModel extends ResponseOfListOfTransactionInfoViewModel implements IPagedResponseOfListOfTransactionInfoViewModel {
    totalRecords?: number;

    constructor(data?: IPagedResponseOfListOfTransactionInfoViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): PagedResponseOfListOfTransactionInfoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfListOfTransactionInfoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRecords"] = this.totalRecords;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResponseOfListOfTransactionInfoViewModel extends IResponseOfListOfTransactionInfoViewModel {
    totalRecords?: number;
}

export class TransactionInfoViewModel implements ITransactionInfoViewModel {
    id?: number;
    operationType?: number;
    statusType?: number;
    amount?: number;
    currentBalance?: number;
    walletId?: number;
    userId?: number;
    trCode?: number;
    paymentMethod?: number | undefined;
    verifyDate?: Date | undefined;
    comment?: string | undefined;
    createOn?: Date;
    operationTitle?: string;
    statusTitle?: string;

    constructor(data?: ITransactionInfoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationType = _data["operationType"];
            this.statusType = _data["statusType"];
            this.amount = _data["amount"];
            this.currentBalance = _data["currentBalance"];
            this.walletId = _data["walletId"];
            this.userId = _data["userId"];
            this.trCode = _data["trCode"];
            this.paymentMethod = _data["paymentMethod"];
            this.verifyDate = _data["verifyDate"] ? new Date(_data["verifyDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.createOn = _data["createOn"] ? new Date(_data["createOn"].toString()) : <any>undefined;
            this.operationTitle = _data["operationTitle"];
            this.statusTitle = _data["statusTitle"];
        }
    }

    static fromJS(data: any): TransactionInfoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionInfoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationType"] = this.operationType;
        data["statusType"] = this.statusType;
        data["amount"] = this.amount;
        data["currentBalance"] = this.currentBalance;
        data["walletId"] = this.walletId;
        data["userId"] = this.userId;
        data["trCode"] = this.trCode;
        data["paymentMethod"] = this.paymentMethod;
        data["verifyDate"] = this.verifyDate ? this.verifyDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["createOn"] = this.createOn ? this.createOn.toISOString() : <any>undefined;
        data["operationTitle"] = this.operationTitle;
        data["statusTitle"] = this.statusTitle;
        return data;
    }
}

export interface ITransactionInfoViewModel {
    id?: number;
    operationType?: number;
    statusType?: number;
    amount?: number;
    currentBalance?: number;
    walletId?: number;
    userId?: number;
    trCode?: number;
    paymentMethod?: number | undefined;
    verifyDate?: Date | undefined;
    comment?: string | undefined;
    createOn?: Date;
    operationTitle?: string;
    statusTitle?: string;
}

export class GatewayViewModel implements IGatewayViewModel {
    id?: number;
    title?: string | undefined;
    imageId?: number;
    minAmount?: number;
    maxAmount?: number;
    currencyTitle?: string | undefined;

    constructor(data?: IGatewayViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.imageId = _data["imageId"];
            this.minAmount = _data["minAmount"];
            this.maxAmount = _data["maxAmount"];
            this.currencyTitle = _data["currencyTitle"];
        }
    }

    static fromJS(data: any): GatewayViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["imageId"] = this.imageId;
        data["minAmount"] = this.minAmount;
        data["maxAmount"] = this.maxAmount;
        data["currencyTitle"] = this.currencyTitle;
        return data;
    }
}

export interface IGatewayViewModel {
    id?: number;
    title?: string | undefined;
    imageId?: number;
    minAmount?: number;
    maxAmount?: number;
    currencyTitle?: string | undefined;
}

export class LoginResultViewModel implements ILoginResultViewModel {
    token?: string | undefined;
    refreshToken?: string | undefined;
    profileInfo?: ProfileInfoViewModel | undefined;

    constructor(data?: ILoginResultViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
            this.profileInfo = _data["profileInfo"] ? ProfileInfoViewModel.fromJS(_data["profileInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LoginResultViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResultViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        data["profileInfo"] = this.profileInfo ? this.profileInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILoginResultViewModel {
    token?: string | undefined;
    refreshToken?: string | undefined;
    profileInfo?: ProfileInfoViewModel | undefined;
}

export class ProfileInfoViewModel implements IProfileInfoViewModel {
    userId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    nationalCode?: string | undefined;
    userName?: string;
    displayName?: string | undefined;
    mobileNumber?: string | undefined;
    genderType?: number;
    profileImageName?: string | undefined;
    lastBalance?: number;
    unreadNotificationCount?: number;
    birthDay?: Date | undefined;
    inviteCode?: string | undefined;
    mobileVerified?: boolean | undefined;
    emailVerified?: boolean;

    constructor(data?: IProfileInfoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.nationalCode = _data["nationalCode"];
            this.userName = _data["userName"];
            this.displayName = _data["displayName"];
            this.mobileNumber = _data["mobileNumber"];
            this.genderType = _data["genderType"];
            this.profileImageName = _data["profileImageName"];
            this.lastBalance = _data["lastBalance"];
            this.unreadNotificationCount = _data["unreadNotificationCount"];
            this.birthDay = _data["birthDay"] ? new Date(_data["birthDay"].toString()) : <any>undefined;
            this.inviteCode = _data["inviteCode"];
            this.mobileVerified = _data["mobileVerified"];
            this.emailVerified = _data["emailVerified"];
        }
    }

    static fromJS(data: any): ProfileInfoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileInfoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["nationalCode"] = this.nationalCode;
        data["userName"] = this.userName;
        data["displayName"] = this.displayName;
        data["mobileNumber"] = this.mobileNumber;
        data["genderType"] = this.genderType;
        data["profileImageName"] = this.profileImageName;
        data["lastBalance"] = this.lastBalance;
        data["unreadNotificationCount"] = this.unreadNotificationCount;
        data["birthDay"] = this.birthDay ? this.birthDay.toISOString() : <any>undefined;
        data["inviteCode"] = this.inviteCode;
        data["mobileVerified"] = this.mobileVerified;
        data["emailVerified"] = this.emailVerified;
        return data;
    }
}

export interface IProfileInfoViewModel {
    userId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    nationalCode?: string | undefined;
    userName?: string;
    displayName?: string | undefined;
    mobileNumber?: string | undefined;
    genderType?: number;
    profileImageName?: string | undefined;
    lastBalance?: number;
    unreadNotificationCount?: number;
    birthDay?: Date | undefined;
    inviteCode?: string | undefined;
    mobileVerified?: boolean | undefined;
    emailVerified?: boolean;
}

export class RegisterViewModel implements IRegisterViewModel {
    userName!: string;
    password!: string;
    email!: string;
    mobileNumber!: string;
    inviteCode?: string | undefined;
    captchaId?: string | undefined;
    captchaCode?: string | undefined;

    constructor(data?: IRegisterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.mobileNumber = _data["mobileNumber"];
            this.inviteCode = _data["inviteCode"];
            this.captchaId = _data["captchaId"];
            this.captchaCode = _data["captchaCode"];
        }
    }

    static fromJS(data: any): RegisterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["email"] = this.email;
        data["mobileNumber"] = this.mobileNumber;
        data["inviteCode"] = this.inviteCode;
        data["captchaId"] = this.captchaId;
        data["captchaCode"] = this.captchaCode;
        return data;
    }
}

export interface IRegisterViewModel {
    userName: string;
    password: string;
    email: string;
    mobileNumber: string;
    inviteCode?: string | undefined;
    captchaId?: string | undefined;
    captchaCode?: string | undefined;
}

export class LoginViewModel implements ILoginViewModel {
    userName?: string;
    password?: string;
    captchaId?: string | undefined;
    captchaCode?: string | undefined;

    constructor(data?: ILoginViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.captchaId = _data["captchaId"];
            this.captchaCode = _data["captchaCode"];
        }
    }

    static fromJS(data: any): LoginViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["captchaId"] = this.captchaId;
        data["captchaCode"] = this.captchaCode;
        return data;
    }
}

export interface ILoginViewModel {
    userName?: string;
    password?: string;
    captchaId?: string | undefined;
    captchaCode?: string | undefined;
}

export class PanelLoginResultViewModel implements IPanelLoginResultViewModel {
    token?: string | undefined;
    refreshToken?: string | undefined;
    resourceIds?: number[] | undefined;
    profileInfo?: PanelInfoViewModel | undefined;

    constructor(data?: IPanelLoginResultViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
            if (Array.isArray(_data["resourceIds"])) {
                this.resourceIds = [] as any;
                for (let item of _data["resourceIds"])
                    this.resourceIds!.push(item);
            }
            this.profileInfo = _data["profileInfo"] ? PanelInfoViewModel.fromJS(_data["profileInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PanelLoginResultViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PanelLoginResultViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        if (Array.isArray(this.resourceIds)) {
            data["resourceIds"] = [];
            for (let item of this.resourceIds)
                data["resourceIds"].push(item);
        }
        data["profileInfo"] = this.profileInfo ? this.profileInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPanelLoginResultViewModel {
    token?: string | undefined;
    refreshToken?: string | undefined;
    resourceIds?: number[] | undefined;
    profileInfo?: PanelInfoViewModel | undefined;
}

export class PanelInfoViewModel implements IPanelInfoViewModel {
    userId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    displayName?: string | undefined;
    profileImageName?: string | undefined;
    unseenWithdrawalCount?: number;
    unseenSuggestionCount?: number;

    constructor(data?: IPanelInfoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.displayName = _data["displayName"];
            this.profileImageName = _data["profileImageName"];
            this.unseenWithdrawalCount = _data["unseenWithdrawalCount"];
            this.unseenSuggestionCount = _data["unseenSuggestionCount"];
        }
    }

    static fromJS(data: any): PanelInfoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PanelInfoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["displayName"] = this.displayName;
        data["profileImageName"] = this.profileImageName;
        data["unseenWithdrawalCount"] = this.unseenWithdrawalCount;
        data["unseenSuggestionCount"] = this.unseenSuggestionCount;
        return data;
    }
}

export interface IPanelInfoViewModel {
    userId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    displayName?: string | undefined;
    profileImageName?: string | undefined;
    unseenWithdrawalCount?: number;
    unseenSuggestionCount?: number;
}

export class RefreshTokenViewModel implements IRefreshTokenViewModel {
    token?: string | undefined;
    refreshToken?: string | undefined;

    constructor(data?: IRefreshTokenViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshTokenViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshTokenViewModel {
    token?: string | undefined;
    refreshToken?: string | undefined;
}

export class Token implements IToken {
    refreshToken!: string;

    constructor(data?: IToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): Token {
        data = typeof data === 'object' ? data : {};
        let result = new Token();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IToken {
    refreshToken: string;
}

export class ResetPasswordViewModel implements IResetPasswordViewModel {
    password!: string;
    forgetToken!: string;

    constructor(data?: IResetPasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.forgetToken = _data["forgetToken"];
        }
    }

    static fromJS(data: any): ResetPasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["forgetToken"] = this.forgetToken;
        return data;
    }
}

export interface IResetPasswordViewModel {
    password: string;
    forgetToken: string;
}

export class PostMessageViewModel implements IPostMessageViewModel {
    userId?: number;
    subject?: string | undefined;
    messageContent?: string | undefined;

    constructor(data?: IPostMessageViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.subject = _data["subject"];
            this.messageContent = _data["messageContent"];
        }
    }

    static fromJS(data: any): PostMessageViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PostMessageViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["subject"] = this.subject;
        data["messageContent"] = this.messageContent;
        return data;
    }
}

export interface IPostMessageViewModel {
    userId?: number;
    subject?: string | undefined;
    messageContent?: string | undefined;
}

export class ResponseOfListOfMessages implements IResponseOfListOfMessages {
    data?: Messages[];

    constructor(data?: IResponseOfListOfMessages) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Messages.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseOfListOfMessages {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfListOfMessages();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseOfListOfMessages {
    data?: Messages[];
}

export class PagedResponseOfListOfMessages extends ResponseOfListOfMessages implements IPagedResponseOfListOfMessages {
    totalRecords?: number;

    constructor(data?: IPagedResponseOfListOfMessages) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): PagedResponseOfListOfMessages {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfListOfMessages();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRecords"] = this.totalRecords;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResponseOfListOfMessages extends IResponseOfListOfMessages {
    totalRecords?: number;
}

export class Messages implements IMessages {
    id?: number;
    userId?: number;
    panelMessageId?: number | undefined;
    subject?: string | undefined;
    messageContent?: string | undefined;
    isRead?: boolean;
    readDate?: Date | undefined;
    isDeleted?: boolean;
    creatorId?: number;
    createOn?: Date;

    constructor(data?: IMessages) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.panelMessageId = _data["panelMessageId"];
            this.subject = _data["subject"];
            this.messageContent = _data["messageContent"];
            this.isRead = _data["isRead"];
            this.readDate = _data["readDate"] ? new Date(_data["readDate"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.creatorId = _data["creatorId"];
            this.createOn = _data["createOn"] ? new Date(_data["createOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Messages {
        data = typeof data === 'object' ? data : {};
        let result = new Messages();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["panelMessageId"] = this.panelMessageId;
        data["subject"] = this.subject;
        data["messageContent"] = this.messageContent;
        data["isRead"] = this.isRead;
        data["readDate"] = this.readDate ? this.readDate.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["creatorId"] = this.creatorId;
        data["createOn"] = this.createOn ? this.createOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IMessages {
    id?: number;
    userId?: number;
    panelMessageId?: number | undefined;
    subject?: string | undefined;
    messageContent?: string | undefined;
    isRead?: boolean;
    readDate?: Date | undefined;
    isDeleted?: boolean;
    creatorId?: number;
    createOn?: Date;
}

export class PaginationData implements IPaginationData {
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IPaginationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): PaginationData {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IPaginationData {
    pageNumber?: number;
    pageSize?: number;
}

export class Role implements IRole {
    id?: number;
    title?: string | undefined;
    comment?: string | undefined;
    creatorId?: number;
    createOn?: Date;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.comment = _data["comment"];
            this.creatorId = _data["creatorId"];
            this.createOn = _data["createOn"] ? new Date(_data["createOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["comment"] = this.comment;
        data["creatorId"] = this.creatorId;
        data["createOn"] = this.createOn ? this.createOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRole {
    id?: number;
    title?: string | undefined;
    comment?: string | undefined;
    creatorId?: number;
    createOn?: Date;
}

export class Resources implements IResources {
    id?: number;
    resourceKey?: string | undefined;
    resourceName?: string | undefined;
    createOn?: Date;

    constructor(data?: IResources) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.resourceKey = _data["resourceKey"];
            this.resourceName = _data["resourceName"];
            this.createOn = _data["createOn"] ? new Date(_data["createOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Resources {
        data = typeof data === 'object' ? data : {};
        let result = new Resources();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["resourceKey"] = this.resourceKey;
        data["resourceName"] = this.resourceName;
        data["createOn"] = this.createOn ? this.createOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IResources {
    id?: number;
    resourceKey?: string | undefined;
    resourceName?: string | undefined;
    createOn?: Date;
}

export class AccessibleResourceViewModel implements IAccessibleResourceViewModel {
    resourceId?: number;
    resourceName?: string | undefined;
    resourceKey?: string | undefined;
    isAccess?: boolean;

    constructor(data?: IAccessibleResourceViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"];
            this.resourceName = _data["resourceName"];
            this.resourceKey = _data["resourceKey"];
            this.isAccess = _data["isAccess"];
        }
    }

    static fromJS(data: any): AccessibleResourceViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AccessibleResourceViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["resourceName"] = this.resourceName;
        data["resourceKey"] = this.resourceKey;
        data["isAccess"] = this.isAccess;
        return data;
    }
}

export interface IAccessibleResourceViewModel {
    resourceId?: number;
    resourceName?: string | undefined;
    resourceKey?: string | undefined;
    isAccess?: boolean;
}

export class SetRolePolicyViewModel implements ISetRolePolicyViewModel {
    roleId?: number;
    resourceIds?: number[] | undefined;

    constructor(data?: ISetRolePolicyViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            if (Array.isArray(_data["resourceIds"])) {
                this.resourceIds = [] as any;
                for (let item of _data["resourceIds"])
                    this.resourceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SetRolePolicyViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SetRolePolicyViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        if (Array.isArray(this.resourceIds)) {
            data["resourceIds"] = [];
            for (let item of this.resourceIds)
                data["resourceIds"].push(item);
        }
        return data;
    }
}

export interface ISetRolePolicyViewModel {
    roleId?: number;
    resourceIds?: number[] | undefined;
}

export class ResponseOfListOfUserGetListViewModel implements IResponseOfListOfUserGetListViewModel {
    data?: UserGetListViewModel[];

    constructor(data?: IResponseOfListOfUserGetListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserGetListViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseOfListOfUserGetListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfListOfUserGetListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseOfListOfUserGetListViewModel {
    data?: UserGetListViewModel[];
}

export class PagedResponseOfListOfUserGetListViewModel extends ResponseOfListOfUserGetListViewModel implements IPagedResponseOfListOfUserGetListViewModel {
    totalRecords?: number;

    constructor(data?: IPagedResponseOfListOfUserGetListViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): PagedResponseOfListOfUserGetListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfListOfUserGetListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRecords"] = this.totalRecords;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResponseOfListOfUserGetListViewModel extends IResponseOfListOfUserGetListViewModel {
    totalRecords?: number;
}

export class UserGetListViewModel implements IUserGetListViewModel {
    id?: number;
    userName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    displayName?: string | undefined;
    genderType?: number;
    mobileNumber?: string | undefined;
    countryCode?: string | undefined;
    countryIso?: string | undefined;
    email?: string | undefined;
    nationalCode?: string | undefined;
    isActive?: boolean;
    profilePictureName?: string | undefined;
    isBane?: boolean;
    lastLoggedIn?: Date | undefined;
    registerDate?: Date;
    lastBalance?: number;
    registrationIp?: string | undefined;

    constructor(data?: IUserGetListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.displayName = _data["displayName"];
            this.genderType = _data["genderType"];
            this.mobileNumber = _data["mobileNumber"];
            this.countryCode = _data["countryCode"];
            this.countryIso = _data["countryIso"];
            this.email = _data["email"];
            this.nationalCode = _data["nationalCode"];
            this.isActive = _data["isActive"];
            this.profilePictureName = _data["profilePictureName"];
            this.isBane = _data["isBane"];
            this.lastLoggedIn = _data["lastLoggedIn"] ? new Date(_data["lastLoggedIn"].toString()) : <any>undefined;
            this.registerDate = _data["registerDate"] ? new Date(_data["registerDate"].toString()) : <any>undefined;
            this.lastBalance = _data["lastBalance"];
            this.registrationIp = _data["registrationIp"];
        }
    }

    static fromJS(data: any): UserGetListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserGetListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["displayName"] = this.displayName;
        data["genderType"] = this.genderType;
        data["mobileNumber"] = this.mobileNumber;
        data["countryCode"] = this.countryCode;
        data["countryIso"] = this.countryIso;
        data["email"] = this.email;
        data["nationalCode"] = this.nationalCode;
        data["isActive"] = this.isActive;
        data["profilePictureName"] = this.profilePictureName;
        data["isBane"] = this.isBane;
        data["lastLoggedIn"] = this.lastLoggedIn ? this.lastLoggedIn.toISOString() : <any>undefined;
        data["registerDate"] = this.registerDate ? this.registerDate.toISOString() : <any>undefined;
        data["lastBalance"] = this.lastBalance;
        data["registrationIp"] = this.registrationIp;
        return data;
    }
}

export interface IUserGetListViewModel {
    id?: number;
    userName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    displayName?: string | undefined;
    genderType?: number;
    mobileNumber?: string | undefined;
    countryCode?: string | undefined;
    countryIso?: string | undefined;
    email?: string | undefined;
    nationalCode?: string | undefined;
    isActive?: boolean;
    profilePictureName?: string | undefined;
    isBane?: boolean;
    lastLoggedIn?: Date | undefined;
    registerDate?: Date;
    lastBalance?: number;
    registrationIp?: string | undefined;
}

export class UserGetListFilterViewModel implements IUserGetListFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    userId?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    nationalCode?: string | undefined;
    displayName?: string | undefined;
    registrationIp?: string | undefined;
    mobileNumber?: string | undefined;
    registerDate?: Date | undefined;
    isActive?: boolean | undefined;
    isBane?: boolean | undefined;
    balance?: number | undefined;

    constructor(data?: IUserGetListFilterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.nationalCode = _data["nationalCode"];
            this.displayName = _data["displayName"];
            this.registrationIp = _data["registrationIp"];
            this.mobileNumber = _data["mobileNumber"];
            this.registerDate = _data["registerDate"] ? new Date(_data["registerDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isBane = _data["isBane"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): UserGetListFilterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserGetListFilterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["nationalCode"] = this.nationalCode;
        data["displayName"] = this.displayName;
        data["registrationIp"] = this.registrationIp;
        data["mobileNumber"] = this.mobileNumber;
        data["registerDate"] = this.registerDate ? this.registerDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isBane"] = this.isBane;
        data["balance"] = this.balance;
        return data;
    }
}

export interface IUserGetListFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    userId?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    nationalCode?: string | undefined;
    displayName?: string | undefined;
    registrationIp?: string | undefined;
    mobileNumber?: string | undefined;
    registerDate?: Date | undefined;
    isActive?: boolean | undefined;
    isBane?: boolean | undefined;
    balance?: number | undefined;
}

export class UserViewModel implements IUserViewModel {
    userId?: number;
    password?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    nationalCode?: string | undefined;
    profilePictureName?: string | undefined;
    userName?: string | undefined;
    displayName?: string | undefined;
    mobileNumber?: string | undefined;
    countryCode?: string | undefined;
    countryIso?: string | undefined;
    genderType?: number;
    isActive?: boolean;
    isBane?: boolean;
    chatStatus?: number;
    isPanelUser?: boolean;
    roles?: AccessibleRoleViewModel[] | undefined;
    birthDay?: Date | undefined;

    constructor(data?: IUserViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.nationalCode = _data["nationalCode"];
            this.profilePictureName = _data["profilePictureName"];
            this.userName = _data["userName"];
            this.displayName = _data["displayName"];
            this.mobileNumber = _data["mobileNumber"];
            this.countryCode = _data["countryCode"];
            this.countryIso = _data["countryIso"];
            this.genderType = _data["genderType"];
            this.isActive = _data["isActive"];
            this.isBane = _data["isBane"];
            this.chatStatus = _data["chatStatus"];
            this.isPanelUser = _data["isPanelUser"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(AccessibleRoleViewModel.fromJS(item));
            }
            this.birthDay = _data["birthDay"] ? new Date(_data["birthDay"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["nationalCode"] = this.nationalCode;
        data["profilePictureName"] = this.profilePictureName;
        data["userName"] = this.userName;
        data["displayName"] = this.displayName;
        data["mobileNumber"] = this.mobileNumber;
        data["countryCode"] = this.countryCode;
        data["countryIso"] = this.countryIso;
        data["genderType"] = this.genderType;
        data["isActive"] = this.isActive;
        data["isBane"] = this.isBane;
        data["chatStatus"] = this.chatStatus;
        data["isPanelUser"] = this.isPanelUser;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["birthDay"] = this.birthDay ? this.birthDay.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserViewModel {
    userId?: number;
    password?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    nationalCode?: string | undefined;
    profilePictureName?: string | undefined;
    userName?: string | undefined;
    displayName?: string | undefined;
    mobileNumber?: string | undefined;
    countryCode?: string | undefined;
    countryIso?: string | undefined;
    genderType?: number;
    isActive?: boolean;
    isBane?: boolean;
    chatStatus?: number;
    isPanelUser?: boolean;
    roles?: AccessibleRoleViewModel[] | undefined;
    birthDay?: Date | undefined;
}

export class AccessibleRoleViewModel implements IAccessibleRoleViewModel {
    roleId?: number;
    roleName?: string | undefined;
    isAccess?: boolean;

    constructor(data?: IAccessibleRoleViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.isAccess = _data["isAccess"];
        }
    }

    static fromJS(data: any): AccessibleRoleViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AccessibleRoleViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["isAccess"] = this.isAccess;
        return data;
    }
}

export interface IAccessibleRoleViewModel {
    roleId?: number;
    roleName?: string | undefined;
    isAccess?: boolean;
}

export class ChangePasswordViewModel implements IChangePasswordViewModel {
    currentPassword?: string;
    newPassword?: string;

    constructor(data?: IChangePasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordViewModel {
    currentPassword?: string;
    newPassword?: string;
}

export class UserVerificationRequestResultViewModel implements IUserVerificationRequestResultViewModel {
    userId?: number;
    status?: number;
    message?: string | undefined;

    constructor(data?: IUserVerificationRequestResultViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.status = _data["status"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): UserVerificationRequestResultViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserVerificationRequestResultViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["status"] = this.status;
        data["message"] = this.message;
        return data;
    }
}

export interface IUserVerificationRequestResultViewModel {
    userId?: number;
    status?: number;
    message?: string | undefined;
}

export class UserVerificationRequestViewModel implements IUserVerificationRequestViewModel {
    verifyType?: number;
    verifyValue?: string | undefined;

    constructor(data?: IUserVerificationRequestViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.verifyType = _data["verifyType"];
            this.verifyValue = _data["verifyValue"];
        }
    }

    static fromJS(data: any): UserVerificationRequestViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserVerificationRequestViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["verifyType"] = this.verifyType;
        data["verifyValue"] = this.verifyValue;
        return data;
    }
}

export interface IUserVerificationRequestViewModel {
    verifyType?: number;
    verifyValue?: string | undefined;
}

export class UserVerificationViewModel implements IUserVerificationViewModel {
    verifyType?: number;
    code?: string | undefined;

    constructor(data?: IUserVerificationViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.verifyType = _data["verifyType"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): UserVerificationViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserVerificationViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["verifyType"] = this.verifyType;
        data["code"] = this.code;
        return data;
    }
}

export interface IUserVerificationViewModel {
    verifyType?: number;
    code?: string | undefined;
}

export class ResponseOfListOfInviteHistoryViewModel implements IResponseOfListOfInviteHistoryViewModel {
    data?: InviteHistoryViewModel[];

    constructor(data?: IResponseOfListOfInviteHistoryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(InviteHistoryViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseOfListOfInviteHistoryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfListOfInviteHistoryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseOfListOfInviteHistoryViewModel {
    data?: InviteHistoryViewModel[];
}

export class PagedResponseOfListOfInviteHistoryViewModel extends ResponseOfListOfInviteHistoryViewModel implements IPagedResponseOfListOfInviteHistoryViewModel {
    totalRecords?: number;

    constructor(data?: IPagedResponseOfListOfInviteHistoryViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): PagedResponseOfListOfInviteHistoryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfListOfInviteHistoryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRecords"] = this.totalRecords;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResponseOfListOfInviteHistoryViewModel extends IResponseOfListOfInviteHistoryViewModel {
    totalRecords?: number;
}

export class InviteHistoryViewModel implements IInviteHistoryViewModel {
    id?: number;
    parentUserId?: number;
    userId?: number;
    registerDate?: Date;
    isGetGift?: boolean;
    giftAmount?: number | undefined;
    giftDate?: Date | undefined;
    emailVerified?: boolean;
    hasSuccessDeposit?: boolean;

    constructor(data?: IInviteHistoryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentUserId = _data["parentUserId"];
            this.userId = _data["userId"];
            this.registerDate = _data["registerDate"] ? new Date(_data["registerDate"].toString()) : <any>undefined;
            this.isGetGift = _data["isGetGift"];
            this.giftAmount = _data["giftAmount"];
            this.giftDate = _data["giftDate"] ? new Date(_data["giftDate"].toString()) : <any>undefined;
            this.emailVerified = _data["emailVerified"];
            this.hasSuccessDeposit = _data["hasSuccessDeposit"];
        }
    }

    static fromJS(data: any): InviteHistoryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new InviteHistoryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentUserId"] = this.parentUserId;
        data["userId"] = this.userId;
        data["registerDate"] = this.registerDate ? this.registerDate.toISOString() : <any>undefined;
        data["isGetGift"] = this.isGetGift;
        data["giftAmount"] = this.giftAmount;
        data["giftDate"] = this.giftDate ? this.giftDate.toISOString() : <any>undefined;
        data["emailVerified"] = this.emailVerified;
        data["hasSuccessDeposit"] = this.hasSuccessDeposit;
        return data;
    }
}

export interface IInviteHistoryViewModel {
    id?: number;
    parentUserId?: number;
    userId?: number;
    registerDate?: Date;
    isGetGift?: boolean;
    giftAmount?: number | undefined;
    giftDate?: Date | undefined;
    emailVerified?: boolean;
    hasSuccessDeposit?: boolean;
}

export class InviteHistoryFilterViewModel implements IInviteHistoryFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    parentUserId?: number;
    userId?: number | undefined;
    fromRegisterDate?: Date | undefined;
    toRegisterDate?: Date | undefined;
    isGetGift?: boolean | undefined;
    emailVerified?: boolean | undefined;

    constructor(data?: IInviteHistoryFilterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.parentUserId = _data["parentUserId"];
            this.userId = _data["userId"];
            this.fromRegisterDate = _data["fromRegisterDate"] ? new Date(_data["fromRegisterDate"].toString()) : <any>undefined;
            this.toRegisterDate = _data["toRegisterDate"] ? new Date(_data["toRegisterDate"].toString()) : <any>undefined;
            this.isGetGift = _data["isGetGift"];
            this.emailVerified = _data["emailVerified"];
        }
    }

    static fromJS(data: any): InviteHistoryFilterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new InviteHistoryFilterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["parentUserId"] = this.parentUserId;
        data["userId"] = this.userId;
        data["fromRegisterDate"] = this.fromRegisterDate ? this.fromRegisterDate.toISOString() : <any>undefined;
        data["toRegisterDate"] = this.toRegisterDate ? this.toRegisterDate.toISOString() : <any>undefined;
        data["isGetGift"] = this.isGetGift;
        data["emailVerified"] = this.emailVerified;
        return data;
    }
}

export interface IInviteHistoryFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    parentUserId?: number;
    userId?: number | undefined;
    fromRegisterDate?: Date | undefined;
    toRegisterDate?: Date | undefined;
    isGetGift?: boolean | undefined;
    emailVerified?: boolean | undefined;
}

export class KeyValueViewModel implements IKeyValueViewModel {
    key?: number;
    value?: string;

    constructor(data?: IKeyValueViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): KeyValueViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValueViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IKeyValueViewModel {
    key?: number;
    value?: string;
}

export class ResponseOfListOfLogResponseViewModel implements IResponseOfListOfLogResponseViewModel {
    data?: LogResponseViewModel[];

    constructor(data?: IResponseOfListOfLogResponseViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(LogResponseViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseOfListOfLogResponseViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfListOfLogResponseViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseOfListOfLogResponseViewModel {
    data?: LogResponseViewModel[];
}

export class PagedResponseOfListOfLogResponseViewModel extends ResponseOfListOfLogResponseViewModel implements IPagedResponseOfListOfLogResponseViewModel {
    totalRecords?: number;

    constructor(data?: IPagedResponseOfListOfLogResponseViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): PagedResponseOfListOfLogResponseViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfListOfLogResponseViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRecords"] = this.totalRecords;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResponseOfListOfLogResponseViewModel extends IResponseOfListOfLogResponseViewModel {
    totalRecords?: number;
}

export class LogResponseViewModel implements ILogResponseViewModel {
    level?: number;
    levelTitle?: string | undefined;
    methodName?: string | undefined;
    message?: string | undefined;
    stackTrace?: string | undefined;
    createDate?: Date;

    constructor(data?: ILogResponseViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.levelTitle = _data["levelTitle"];
            this.methodName = _data["methodName"];
            this.message = _data["message"];
            this.stackTrace = _data["stackTrace"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LogResponseViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LogResponseViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["levelTitle"] = this.levelTitle;
        data["methodName"] = this.methodName;
        data["message"] = this.message;
        data["stackTrace"] = this.stackTrace;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ILogResponseViewModel {
    level?: number;
    levelTitle?: string | undefined;
    methodName?: string | undefined;
    message?: string | undefined;
    stackTrace?: string | undefined;
    createDate?: Date;
}

export class LogFilterViewModel implements ILogFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    level?: number | undefined;
    methodName?: string | undefined;
    message?: string | undefined;
    stackTrace?: string | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;

    constructor(data?: ILogFilterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.level = _data["level"];
            this.methodName = _data["methodName"];
            this.message = _data["message"];
            this.stackTrace = _data["stackTrace"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LogFilterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LogFilterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["level"] = this.level;
        data["methodName"] = this.methodName;
        data["message"] = this.message;
        data["stackTrace"] = this.stackTrace;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ILogFilterViewModel {
    pageNumber?: number;
    pageSize?: number;
    level?: number | undefined;
    methodName?: string | undefined;
    message?: string | undefined;
    stackTrace?: string | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
}

export class EmailTemplate implements IEmailTemplate {
    id?: number;
    subject?: string | undefined;
    emailContent?: string | undefined;
    sendType?: number;
    isSend?: boolean;
    senderId?: number | undefined;
    sendDate?: Date | undefined;
    filterValue?: string | undefined;
    creatorId?: number;
    createOn?: Date;

    constructor(data?: IEmailTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subject = _data["subject"];
            this.emailContent = _data["emailContent"];
            this.sendType = _data["sendType"];
            this.isSend = _data["isSend"];
            this.senderId = _data["senderId"];
            this.sendDate = _data["sendDate"] ? new Date(_data["sendDate"].toString()) : <any>undefined;
            this.filterValue = _data["filterValue"];
            this.creatorId = _data["creatorId"];
            this.createOn = _data["createOn"] ? new Date(_data["createOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmailTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subject"] = this.subject;
        data["emailContent"] = this.emailContent;
        data["sendType"] = this.sendType;
        data["isSend"] = this.isSend;
        data["senderId"] = this.senderId;
        data["sendDate"] = this.sendDate ? this.sendDate.toISOString() : <any>undefined;
        data["filterValue"] = this.filterValue;
        data["creatorId"] = this.creatorId;
        data["createOn"] = this.createOn ? this.createOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IEmailTemplate {
    id?: number;
    subject?: string | undefined;
    emailContent?: string | undefined;
    sendType?: number;
    isSend?: boolean;
    senderId?: number | undefined;
    sendDate?: Date | undefined;
    filterValue?: string | undefined;
    creatorId?: number;
    createOn?: Date;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}